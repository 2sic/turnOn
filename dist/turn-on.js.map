{"version":3,"file":"turn-on.js","mappings":"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","sources":["webpack://turn-on/./src/turnOn/settings.ts","webpack://turn-on/./src/configuration/configuration.ts","webpack://turn-on/./src/configuration/config-helper.ts","webpack://turn-on/./src/constants.ts","webpack://turn-on/./src/debug.ts","webpack://turn-on/./src/tags/config-tag.ts","webpack://turn-on/./src/conditions/exists-progress.ts","webpack://turn-on/./src/tags/config-tag-manager.ts","webpack://turn-on/./src/tags/config-to-turn-on.ts","webpack://turn-on/./src/tags/tag-loader.ts","webpack://turn-on/./src/status/status.ts","webpack://turn-on/./src/status/status-summary.ts","webpack://turn-on/./src/watch-promise/condition-as-promise.ts","webpack://turn-on/./src/conditions/condition-function.ts","webpack://turn-on/./src/conditions/condition-name.ts","webpack://turn-on/./src/conditions/condition-function-name.ts","webpack://turn-on/./src/conditions/condition-maker.ts","webpack://turn-on/./src/turnOn/turn-on.ts","webpack://turn-on/./src/watch-promise/promise-boolean-as-promise.ts","webpack://turn-on/./src/turnOn/turn-on-root.ts","webpack://turn-on/./src/index.ts"],"sourcesContent":["\r\n// this must be a simple const, otherwise the annotation below with typeof won't work\r\n// https://stackoverflow.com/questions/56263200/how-to-define-string-literal-union-type-from-constants-in-typescript\r\nexport const LogError = 'error';\r\nexport const LogDebug = 'debug';\r\nexport const LogSilent = 'silent';\r\n\r\nexport const FailSilent = 'silent';\r\nexport const FailResolve = 'resolve';\r\nexport const FailReject = 'reject';\r\nexport const DefaultName = 'turnOn';\r\n\r\nexport type LogMode = typeof LogError | typeof LogDebug | typeof LogSilent;\r\n\r\nexport class Settings {\r\n  /** the polling interval - defaults to 100 */\r\n  interval = 100;\r\n\r\n  /** polling attempts, defaults to 100 */\r\n  attempts = 100;\r\n \r\n  /** What to log into the console */\r\n  log: LogMode = LogError;\r\n\r\n  /**\r\n   * Failure mode, if by timeout it's not successful\r\n   * - reject (default)= use promise reject (which will throw an error if not handled)\r\n   * - resolve = use promise resolve and give a status back which says it's not complete\r\n   * - silent = don't complete the promise\r\n   */\r\n  failure: typeof FailReject | typeof FailResolve | typeof FailSilent = FailReject;\r\n\r\n  /** The name of this turnOn - to better track issues */\r\n  name = DefaultName;\r\n}","import { Settings } from '../turnOn/settings';\r\nexport const Progress1Loaded = '1-loaded';\r\nexport const Progress2Watching = '2-watching';\r\nexport const Progress3Running = '3-running';\r\nexport const Progress4Completed = '4-completed';\r\nexport const Progress9Cancelled = '9-cancelled';\r\nexport const ProgressError = '9-error';\r\n\r\nexport type TurnOnProgress = typeof Progress1Loaded | typeof Progress2Watching  | typeof Progress3Running | typeof Progress4Completed | typeof Progress9Cancelled | typeof ProgressError ;\r\n\r\nexport type AddContextLocation = true | false | 'data' | 'end';\r\n\r\nexport interface TurnOnConfigInternal {\r\n  /** Things to wait for - names on window (or sub-objects) or functions on window or sub-objects */\r\n  await: string[];\r\n\r\n  /** Special flag to log everything that's happening for extensive debugging */\r\n  debug: boolean;\r\n\r\n  /**\r\n   * What to run when all awaits have succeeded. \r\n   * The system will also wait for this to exist before it runs it. \r\n   */\r\n  run: string;\r\n\r\n  /** Information how far processing of this configuration has commenced */\r\n  progress: TurnOnProgress;\r\n\r\n  /** Possible error information */\r\n  error?: string;\r\n\r\n  /** Optional data to give the function once it starts */\r\n  data?: unknown;\r\n\r\n  /**\r\n   * Optional: data as args for the function\r\n   * New in v0.3.0.\r\n   * \r\n   * When provided, data will be ignored?\r\n   */\r\n  args?: unknown[];\r\n\r\n  addContext: AddContextLocation;\r\n\r\n  /** Settings used for this turn-on */\r\n  settings?: Settings\r\n}\r\n","import { TurnOnConfiguration } from '../tags/config-in-tag';\r\nimport { LogMode, Settings, LogError, LogDebug } from '../turnOn/settings';\r\nimport { Progress1Loaded, ProgressError, TurnOnConfigInternal, AddContextLocation } from './configuration';\r\n\r\nexport class ConfigHelper {\r\n\r\n  /**\r\n   * Create a configuration object which just contains an error\r\n   */\r\n  static createError(message: string): TurnOnConfigInternal {\r\n    const result: TurnOnConfigInternal = {\r\n      await: [],\r\n      debug: false,\r\n      run: '',\r\n      progress: ProgressError,\r\n      error: message,\r\n      addContext: false,\r\n    };\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Load a configuration from a string usually from an Html attribute\r\n   */\r\n  static load(value: string): TurnOnConfigInternal {\r\n    let pretyped: TurnOnConfiguration;\r\n    try {\r\n      pretyped = JSON.parse(value);\r\n    }\r\n    catch (ex) {\r\n      return ConfigHelper.createError(`detected configuration but cannot parse to json.`);\r\n    }\r\n\r\n    let configuration: TurnOnConfigInternal;\r\n    try {\r\n      configuration = ConfigHelper.stabilize(pretyped);\r\n    }\r\n    catch (ex) { \r\n      return ConfigHelper.createError(`Error loading configuration, reason unknown.`)\r\n    }\r\n  \r\n    return configuration;\r\n  }\r\n\r\n  /**\r\n   * Import a raw configuration and make sure it's fully compliant\r\n   */\r\n  private static stabilize(raw: TurnOnConfiguration): TurnOnConfigInternal {\r\n    // 1. Start with the run command - ensure it's there and correct\r\n    if(!raw) return ConfigHelper.createError('No turn-on config found to process');\r\n    if(!raw.run) return ConfigHelper.createError(`Config didn't contain 'run' - it's required.`);\r\n    if(!raw.run.startsWith('window')) return ConfigHelper.createError(`run command must start with 'window.' but is:` + raw.run);\r\n    if(!raw.run.endsWith('()')) return ConfigHelper.createError(`run must be a function name and end with () but it's:` + raw.run);\r\n  \r\n    // 2. Get the requires/awaits\r\n    const requiresRaw = raw.require ?? raw.await;\r\n    const requires = Array.isArray(requiresRaw) \r\n          ? requiresRaw\r\n          : requiresRaw\r\n            ? [requiresRaw]\r\n            : [];\r\n  \r\n    // also always await the run command, but without the () as it shouldn't be called to detect if it's ready    \r\n    requires.push(raw.run.substring(0, raw.run.length-2));\r\n  \r\n    // 3. Get the args and ensure it's an array if given\r\n    if(raw.args && !Array.isArray(raw.args))\r\n      return ConfigHelper.createError('args must be an array if given');\r\n\r\n    // 4. Get the log mode\r\n    const logMode: LogMode = (raw?.debug ?? false) ? LogDebug : LogError;\r\n\r\n    const addContext = raw.addContext != null\r\n      ? raw.addContext\r\n      : raw.args\r\n        ? false\r\n        : true;\r\n\r\n    // 5. Get the data object - in classing mode without args, it defaulted to {} but it should not if we have args.\r\n    const data = raw.data ||\r\n      (raw.args ? undefined : {});\r\n\r\n    const stable: TurnOnConfigInternal = {\r\n      await: requires,\r\n      debug: raw.debug ?? false,\r\n      run: raw.run,\r\n      progress: Progress1Loaded,\r\n      data, // give empty object so a developer can see this would exist as an option\r\n      args: raw.args,\r\n      settings: { ...new Settings(), log: logMode, ...raw.settings },\r\n      addContext,\r\n    }\r\n    return stable;\r\n  }\r\n}","\r\nexport const AttributeTurnOn = 'turn-on';\r\nexport const AttributeSkip = 'turn-on-skip';\r\n\r\nexport const WindowName = 'window';\r\n\r\nexport const LogPrefix = 'turn-on: ';","\r\n// const debug = true;\r\n\r\nimport { LogPrefix } from './constants';\r\n\r\nexport function log(message: string, obj1?: unknown, obj2?: unknown): void {\r\n  if(!window.debugTurnOn) return;\r\n  if(obj2) console.log(LogPrefix + message, obj1, obj2);\r\n  else if(obj1)  console.log(LogPrefix + message, obj1);\r\n  else console.log(LogPrefix + message);\r\n}","import { log } from '../debug';\r\nimport { TurnOn } from '../turnOn/turn-on';\r\nimport { ProgressError, TurnOnConfigInternal, TurnOnProgress } from '../configuration/configuration';\r\nimport { AttributeSkip, AttributeTurnOn } from '../constants';\r\n\r\n\r\nexport class ConfigTag {\r\n\r\n  constructor(\r\n    public tag: HTMLElement,\r\n    public config: TurnOnConfigInternal,\r\n    public turnOn?: TurnOn\r\n  ) \r\n  { \r\n    this.syncDom();\r\n  }\r\n\r\n  syncDom(): void {\r\n    log('syncDom', this);\r\n    const tag = this.tag;\r\n    // set skip if missing and update json in html if not current\r\n    // Do these checks to avoid to many DOM changes\r\n    if(!tag.getAttribute(AttributeSkip)) tag.setAttribute(AttributeSkip, \"skip\");\r\n    const currentSerialized = JSON.stringify(this.config);\r\n    if(tag.getAttribute(AttributeTurnOn) !== currentSerialized)\r\n      tag.setAttribute(AttributeTurnOn, currentSerialized);\r\n  }\r\n\r\n  progress(prog: TurnOnProgress): void {\r\n    this.config.progress = prog;\r\n    this.syncDom();\r\n  }\r\n\r\n  error(message: string): void {\r\n    this.config.progress = ProgressError;\r\n    this.config.error = message;\r\n    this.syncDom();\r\n    throw this.config.error;\r\n  }\r\n}","import { WindowName } from '../constants';\r\n\r\n\r\n/**\r\n * Internal Class which will check if a object path like `window.something.other` exists and report back how much of it works.\r\n */\r\nexport class ExistsProgress {\r\n  constructor(\r\n    /** true/false if it succeeded till the end */\r\n    public success: boolean,\r\n\r\n    /** resulting object or method it would call */\r\n    public result: unknown,\r\n\r\n    /** The parent of the resulting object - in case the result was a method which needs to be rebound */\r\n    public parent: unknown,\r\n\r\n    /** name of the last element found - important if the last thing is a function*/\r\n    public lastName: string,\r\n\r\n    /** Amount of parts in the full identifier */\r\n    public parts: number,\r\n\r\n    /** Amount of parts found */\r\n    public partsFound: number,\r\n\r\n    /** Part-path which already worked */\r\n    public matchedKey: string,\r\n  ) { }\r\n\r\n  static test(key: string): ExistsProgress {\r\n    if(!key) return new ExistsProgress(true, null, null, null, 0, 0, \"\");\r\n\r\n    const parts = key.split('.');\r\n    if(parts[0] !== WindowName) throw `Key must start with '${WindowName}.' but it's '${key}'`;\r\n\r\n    // Only contains window, stop here\r\n    if (parts.length == 1) return new ExistsProgress(true, window, null, WindowName, 1, 1, WindowName);\r\n\r\n    let current = window as any;\r\n    let parent = null as any;\r\n    let match = WindowName;\r\n    let partName: string;\r\n    for (let i = 1; i < parts.length; i++) {\r\n      partName = parts[i];\r\n      parent = current;\r\n      current = current[partName];\r\n      // found, so let's add to list of successful matches\r\n      match += '.' + partName;\r\n\r\n      // if node not found, stop checking\r\n      if (!current) return new ExistsProgress(false, null, parent, partName, parts.length, i, match);\r\n    }\r\n    return new ExistsProgress(true, current, parent, partName, parts.length, parts.length, match);\r\n  }\r\n}","import { ConfigHelper } from '../configuration/config-helper';\r\nimport { ProgressError, TurnOnConfigInternal } from '../configuration/configuration';\r\nimport { AttributeSkip, AttributeTurnOn } from '../constants';\r\nimport { ConfigTag } from './config-tag';\r\nimport { log } from '../debug';\r\nimport { convertConfigToTurnOn } from './config-to-turn-on';\r\nimport { TurnOnRoot } from '../turnOn/turn-on-root';\r\n\r\nexport class ConfigTagManager {\r\n  public tags = new Array<ConfigTag>();\r\n\r\n  constructor(public root: TurnOnRoot) {}\r\n\r\n  tryToLoadTag(node: HTMLElement): void {\r\n    // Get config and skip if not relevant, or skip if already marked as in the queue\r\n    const attr = node?.getAttribute?.(AttributeTurnOn);\r\n    if (!attr) return;\r\n    const skip = node?.getAttribute?.(AttributeSkip);\r\n    log('skip', skip);\r\n    if (skip) return log('skip');\r\n\r\n    log('attr', attr);\r\n    const config = ConfigHelper.load(attr);\r\n    if (config.progress === ProgressError) {\r\n      console.error(config.error, node, attr);\r\n      return;\r\n    }\r\n    log('stable config');\r\n    this.add(node, config);\r\n  }\r\n\r\n  /**\r\n   *\r\n   */\r\n  add(node: HTMLElement, config: TurnOnConfigInternal): void {\r\n    log('add', node, config);\r\n    const tag = new ConfigTag(node, config);\r\n    this.tags.push(tag);\r\n    convertConfigToTurnOn(this.root, tag);\r\n  }\r\n\r\n  updateTags(): void {\r\n    log(`updateTags: ${this.tags.length}`);\r\n    this.tags.forEach((t) => t.syncDom());\r\n  }\r\n}\r\n","import { ExistsProgress } from '../conditions/exists-progress';\r\nimport { ContextData } from './context-data';\r\nimport { Progress2Watching, Progress3Running, Progress4Completed, TurnOnConfigInternal } from '../configuration/configuration';\r\nimport { ConfigTag } from './config-tag';\r\nimport { Status } from '../status/status';\r\nimport { log } from '../debug';\r\nimport { TurnOnRoot } from '../turnOn/turn-on-root';\r\n\r\n/**\r\n * \r\n */\r\nexport function convertConfigToTurnOn(root: TurnOnRoot, configTag: ConfigTag): Promise<Status> {\r\n  const config = configTag.config;\r\n  log('convert to turnon');\r\n  const turnOn = root.new(config.settings);\r\n  config.settings = turnOn.settings;\r\n  const promise = turnOn.await(config.await);\r\n  configTag.progress(Progress2Watching);\r\n\r\n  promise.then(() => {\r\n    const run = config.run;\r\n    log('turn on success - will try to run ' + run);\r\n    configTag.progress(Progress3Running);\r\n    if(!run.endsWith('()')) {\r\n      configTag.error(`run should end with () but doesn't - can't continue`);\r\n      return;\r\n    }\r\n\r\n    // check exists without trailing \"()\"\"\r\n    const checkExists = ExistsProgress.test(run.substr(0, run.length - 2));\r\n\r\n    // if node not found or it's not a function, stop checking\r\n    if (!checkExists.success) {\r\n      configTag.error(`Tried to find object parts for ${checkExists.matchedKey} but didn't get anything.`);\r\n      return;\r\n    }\r\n    if (typeof(checkExists.result) !== 'function') {\r\n      configTag.error(`Got ${checkExists.partsFound} but it's not a function`);\r\n      return;\r\n    }\r\n\r\n    // now run it!\r\n    // Special: we can't just run the function we got back\r\n    // because that loses the `this`. So we must run it as a property of the parent\r\n    const data = config.data;\r\n    const contextData: ContextData = { tag: configTag.tag, config: config };\r\n    const fnScopeObject = checkExists.parent as any;\r\n\r\n    // New v0.3.0: if we have args, use them\r\n    if (config.args) {\r\n      const fnArgs = mergeArgsWithDataAndContext(config, contextData);\r\n      fnScopeObject[checkExists.lastName](...fnArgs);\r\n    }\r\n    // Classic run with data only\r\n    else {\r\n      fnScopeObject[checkExists.lastName](data, contextData);\r\n    }\r\n\r\n    configTag.progress(Progress4Completed);\r\n  });\r\n  return promise;\r\n}\r\n\r\nfunction mergeArgsWithDataAndContext(config: TurnOnConfigInternal, contextData: ContextData): unknown[] {\r\n  const data = config.data;\r\n  let fnArgs = config.args;\r\n\r\n  log(`mergeArgsWithDataAndContext`, { config, contextData, data, fnArgs })\r\n\r\n  // if we have data, prepend it to the args, optionally mix with context\r\n  if (config.data != undefined) {\r\n    // merge data with context if addContext is set to `data`\r\n    const argsData = config.addContext === 'data' && (data !== null && typeof data === 'object' && !Array.isArray(data))\r\n      ? { ...contextData, ...data }\r\n      : data;\r\n    fnArgs = [argsData, ...fnArgs];\r\n  }\r\n\r\n  // with or without data - if we should add context to end, do so\r\n  if (config.addContext === 'end')\r\n    fnArgs = [...fnArgs, contextData];\r\n\r\n  return fnArgs;\r\n}","import { AttributeSkip, AttributeTurnOn } from '../constants';\r\nimport { log } from '../debug';\r\nimport { ConfigTagManager } from './config-tag-manager';\r\n\r\n/** Query to find all tags that are not processed yet; processed will be marked with turn-on-skip */\r\nconst queryForUnprocessedTags = `[${AttributeTurnOn}]:not([${AttributeSkip}])`;\r\n\r\nconst ELEMENT_NODE = 1; // see https://developer.mozilla.org/en-US/docs/Web/API/Node\r\n\r\n/**\r\n * In charge of loading all turn-on tags from the DOM, both at first load as well as on DOM changes\r\n */\r\nexport class TagLoader {\r\n  /** Options for the observer (which mutations to observe) */\r\n  private config: MutationObserverInit = {\r\n    attributes: false,\r\n    childList: true,\r\n    subtree: true,\r\n  };\r\n\r\n  /** The observer, in case we need to debug */\r\n  public observer: MutationObserver;\r\n\r\n  constructor(public tagManager: ConfigTagManager) {\r\n    this.scanInitialDom();\r\n    this.activateObserver();\r\n  }\r\n\r\n  /** Scan initial dom */\r\n  private scanInitialDom(): void {\r\n    log('scanInitialDom');\r\n    if (document.documentElement)\r\n      this.checkAndLoadChildren(document.documentElement);\r\n  }\r\n\r\n  private checkAndLoadChildren(parent: HTMLElement) {\r\n    log('checkAndLoadChildren', parent);\r\n    if (!parent?.children?.length) return;\r\n    const tags = parent.querySelectorAll(queryForUnprocessedTags);\r\n    tags.forEach((t: HTMLElement) => this.tagManager.tryToLoadTag(t));\r\n  }\r\n\r\n  public activateObserver(): void {\r\n    log('activateObserver');\r\n\r\n    this.observer = new MutationObserver((mutations) => {\r\n      // const additions = true;\r\n      // const changes = (window as any).turnOnWatchChanges ?? false;\r\n      // log(`mutations detected, processing additions=${additions} and window.turnOnWatchChanges=${changes}`, mutations);\r\n      log(`mutations detected`, mutations);\r\n\r\n      // Loop through each changed item, check if it's something we want to initialize\r\n      mutations.forEach((m) => {\r\n        // Nodes added - let's check if it is a turn-on\r\n        if (m.type != 'childList') return;\r\n        log('childList changes');\r\n\r\n        // if (additions)\r\n        Array.from(m.addedNodes)\r\n          // nodes can contain text and stuff as well, so we must filter first\r\n          .filter((n) => n.nodeType === ELEMENT_NODE)\r\n          .forEach((node: HTMLElement) => {\r\n            if (node?.getAttribute?.(AttributeTurnOn))\r\n              this.tagManager.tryToLoadTag(node);\r\n            else this.checkAndLoadChildren(node);\r\n          });\r\n\r\n        // if (changes)\r\n        //   Array.from(m.addedNodes)\r\n        //     // nodes can contain text and stuff as well, so we must filter first\r\n        //     .filter((n) => n.nodeType === ELEMENT_NODE)\r\n        //     .forEach((node: HTMLElement) => {\r\n        //       if (node?.getAttribute?.(AttributeTurnOn))\r\n        //         this.tagManager.tryToLoadTag(node);\r\n        //       else this.checkAndLoadChildren(node);\r\n        //     });\r\n      });\r\n    });\r\n\r\n    // observe document for tags which include this. ATM don't observe header\r\n    this.observer.observe(document.documentElement, this.config);\r\n  }\r\n}\r\n","\r\nconst nameNotDefined = 'not set';\r\n\r\nexport class Status {\r\n  constructor(\r\n    /** The status type, like window-key, function, summary etc. */\r\n    public type: string,\r\n\r\n    /** Status if the check has been successful */\r\n    public ready: boolean,\r\n\r\n    /** Status message if provided */\r\n    public message: string, \r\n    \r\n    /** name of this status, to better point to which rule failed */\r\n    public name: string = nameNotDefined,\r\n    \r\n    /** result of a check - in some cases needed for next steps */\r\n    public result?: unknown\r\n    ) {\r\n  }\r\n\r\n  /** Amount of attempts tried till this  */\r\n  attempts? = 0;\r\n\r\n}\r\n","import { Status } from './status';\r\n\r\nexport class StatusSummary extends Status {\r\n\r\n  constructor(details: Status[]) {\r\n    // no details provided, then assume ok\r\n    if (!details) details = [];\r\n\r\n    const ready = detectIfAllOk(details);\r\n\r\n    const message = details.length === 0\r\n      ? 'no conditions provided'\r\n      : ready\r\n        ? 'all ok'\r\n        : 'some conditions did not complete';\r\n    super('summary', ready, message, 'Summary');\r\n    this.details = details;\r\n  }\r\n\r\n  /** Details of each of the status received */\r\n  details: Status[]\r\n}\r\n\r\nfunction detectIfAllOk(details: Status[]) {\r\n  // some kind of error appeared, shouldn't be ok\r\n  if (!Array.isArray(details)) return false;\r\n\r\n  // count if all details have a ready-state\r\n  return (details.filter(stat => stat.ready).length == details.length)\r\n}","import { Status } from '../status/status';\r\nimport { Settings } from '../turnOn/settings';\r\n\r\n\r\nconst promiseType = 'promise';\r\nexport class ConditionAsPromise {\r\n\r\n  public settings: Settings;\r\n\r\n  constructor(checkFunction: () => Status, settings: Settings) {\r\n    this.innerCheck = checkFunction;\r\n    this.settings = settings;\r\n  }\r\n\r\n  public lastStatus: Status = new Status(promiseType, false, 'condition not checked yet');\r\n  public attempts = 0;\r\n\r\n  /**\r\n   * Dummy innerCheck function - should be replaced in the constructor\r\n   */\r\n  public innerCheck(): Status { return new Status(promiseType, true, 'no condition defined') }\r\n\r\n  public check(): Status {\r\n    if (this.lastStatus.ready === true) return this.lastStatus;\r\n\r\n    // check and store\r\n    this.lastStatus = this.innerCheck();\r\n\r\n    return this.lastStatus;\r\n  }\r\n\r\n  public asPromise(): Promise<Status> {\r\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n    const parent = this;\r\n    const checkCondition = function(resolve: (value: Status) => void, reject: (reason: unknown | null) => void) {\r\n      // If the condition is met, we're done! \r\n      const result = parent.check();\r\n\r\n      // if all is ok (true) then complete the promise\r\n      if(result.ready === true) {\r\n        resolve( { ...result, attempts: parent.attempts });\r\n        return;\r\n      }\r\n\r\n      if(parent.attempts++ >= parent.settings.attempts) {\r\n        resolve({ ...result, message: 'tried up to max attempts: ' + result.message, attempts: parent.attempts });\r\n        return;\r\n      }\r\n\r\n      // If the condition isn't met but the timeout hasn't elapsed, go again\r\n      setTimeout(checkCondition, parent.settings.interval, resolve, reject);\r\n    };\r\n\r\n    return new Promise(checkCondition)\r\n  }\r\n}\r\n","import { Status } from '../status/status';\r\nimport { Condition } from './condition-type';\r\n\r\n/**\r\n * Create a condition based on a function which will be polled till it returns truthy\r\n */\r\nexport function createFnCondition(fn: () => boolean): Condition {\r\n  let name = fn.toString();\r\n  if (name && name.length > 25) name = name.substr(0, 25);\r\n  return () => { \r\n    return new Status('fn', fn(), '', name);\r\n  }\r\n}","import { WindowName } from '../constants';\r\nimport { Status } from '../status/status';\r\nimport { Condition } from './condition-type';\r\nimport { ExistsProgress } from './exists-progress';\r\n\r\nconst statusType = 'window-key';\r\n\r\n/**\r\n * Create a checker which verifies if a key or key-sequence on window exists\r\n */\r\nexport function createNameCondition(key: string): Condition {\r\n  // empty-ish strings - always say it's done\r\n  if (!key) return () => new Status(statusType, true, 'empty key', key);\r\n  if (key === WindowName) return () => new Status(statusType, true, 'no keys except maybe windows found', key);\r\n\r\n  return () => {\r\n    const exists = ExistsProgress.test(key);\r\n    if(exists.success) return new Status(statusType, true, 'all keys matched', key, exists.result);\r\n    return new Status(statusType, false, `Not all keys matched yet. So far '${exists.matchedKey}' worked.`, key);\r\n  }\r\n}","import { createNameCondition } from './condition-name';\r\nimport { createFnCondition } from './condition-function';\r\nimport { Condition } from './condition-type';\r\n\r\nconst namedFnType = 'named fn';\r\n\r\n/**\r\n * Create a condition which waits for a function to exist, and then polls it till the result is ok.\r\n */\r\nexport function createFunctionNameCondition(key: string): Condition {\r\n  if(!key.endsWith('()')) throw `Tried to create Function-Name condition but that requires it to end with (), got ${key}`;\r\n\r\n  const keyWithoutBrackets = key.substring(0, key.length - 2);\r\n  let fnCondition: Condition;\r\n  const nameCondition = createNameCondition(keyWithoutBrackets);\r\n  return () => {\r\n\r\n    // As long as the name doesn't exist, check that and return that status\r\n    // But only do this till we have the fnCondition once, then skip\r\n    if(!fnCondition) {\r\n      const statusOfName = nameCondition();\r\n      if(!statusOfName.ready) return { ...statusOfName, type: namedFnType} ;\r\n\r\n      // Check if we really got a function - if not, assume all is ok and don't try to call\r\n      if(typeof(statusOfName.result) !== 'function') return { ...statusOfName, type: namedFnType };\r\n      \r\n      // Create the function-condition to use from now on. \r\n      fnCondition = createFnCondition(statusOfName.result as () => boolean);\r\n    }\r\n\r\n    // once the name exists, try to get the function\r\n    return { ...fnCondition(), type: namedFnType };\r\n  }\r\n}","import { createFnCondition } from './condition-function';\r\nimport { createFunctionNameCondition } from './condition-function-name';\r\nimport { createNameCondition } from './condition-name';\r\nimport { Condition, ConditionRaw } from './condition-type';\r\n\r\n/**\r\n * Internal class to generate is-it-ready checkers\r\n */\r\nexport class ConditionMaker {\r\n\r\n  /**\r\n   * Make a new condition checker\r\n   */\r\n  public make(condition: ConditionRaw): Condition {\r\n    if (typeof(condition) === 'function')\r\n      return createFnCondition(condition);\r\n    \r\n    if (typeof(condition) === 'string')\r\n      return condition.endsWith('()')\r\n        ? createFunctionNameCondition(condition)\r\n        : createNameCondition(condition);\r\n  }\r\n}","import { DefaultName, FailReject, FailResolve, FailSilent, LogDebug, LogSilent, Settings } from './settings';\r\nimport { promiseBoolToStatus } from '../watch-promise/promise-boolean-as-promise';\r\nimport { LogPrefix } from '../constants';\r\nimport { Status } from '../status/status';\r\nimport { StatusSummary } from '../status/status-summary';\r\nimport { ConditionRaw } from '../conditions/condition-type';\r\nimport { ConditionAsPromise } from '../watch-promise/condition-as-promise';\r\nimport { ConditionMaker } from '../conditions/condition-maker';\r\n\r\nexport class TurnOn {\r\n\r\n  /** \r\n   * The settings for this turnOn\r\n   */\r\n  public settings;\r\n\r\n  /**\r\n   * Constructor with optional settings\r\n   */\r\n  constructor(nameOrSettings?: Partial<Settings> | string) {\r\n    // Handle case where only a name is provided\r\n    if (typeof nameOrSettings === 'string') {\r\n      nameOrSettings = {\r\n        name: nameOrSettings\r\n      } as Partial<Settings>;\r\n    }\r\n\r\n    // merge settings with default settings ??? not sure why\r\n    if (nameOrSettings)\r\n      this.settings = { ...new Settings(), ...nameOrSettings };\r\n\r\n    TurnOn.count++;\r\n  }\r\n\r\n  /**\r\n   * Create a new turnOn object.\r\n   * Mainly useful in global scenarios, to give it a separate name\r\n   */\r\n  new(nameOrSettings?: Partial<Settings>): TurnOn {\r\n    return new TurnOn(nameOrSettings);\r\n  }\r\n\r\n  /**\r\n   * Old call, renamed to `require` in v0.2\r\n   * @param conditions \r\n   * @returns \r\n   * @deprecated in v0.2, but will probably remain forever, just not documented any more.\r\n   */\r\n  public await(conditions: ConditionRaw | ConditionRaw[]): Promise<Status> { \r\n    return this.require(conditions);\r\n  }\r\n\r\n  /**\r\n   * Require a set of conditions to be met before executing run.\r\n   * @param conditions \r\n   * @returns \r\n   */\r\n  public require(conditions: ConditionRaw | ConditionRaw[]): Promise<Status> {\r\n\r\n    // re-wrap to ensure we always work with an array\r\n    const conditionsArray = (Array.isArray(conditions)) ? conditions : [conditions];\r\n\r\n    // convert conditions to promises\r\n    const loadedCheckers = conditionsArray.map(c => {\r\n      // do this for non-promise conditions\r\n      if (Promise.resolve(c as unknown) === c) {\r\n        return promiseBoolToStatus(c);\r\n      } else {\r\n        const condition = this._conditionMaker.make(c);\r\n        const loaded = new ConditionAsPromise(condition, this.settings);\r\n        return loaded.asPromise();  \r\n      }\r\n    });\r\n\r\n    // keep the current turnOn-object for reference in methods\r\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n    const thisKs = this;\r\n\r\n    // keep count as it was on start, to ensure it doesn't change any more till we log the error\r\n    const instanceCount = TurnOn.count;\r\n\r\n    const flattened = new Promise<StatusSummary>((resolve, reject) => { \r\n      // return a single promise for all inner promises which either fail or resolve\r\n      Promise.all(loadedCheckers).then(list => {\r\n\r\n        // get summary of all details infos\r\n        const summary = new StatusSummary(list);\r\n\r\n        // by default, log details about what failed\r\n        if (window.debugTurnOn || thisKs.settings.log === LogDebug || (!summary.ready && thisKs.settings.log !== LogSilent))\r\n          thisKs.logStatusList(summary.ready, instanceCount, thisKs.settings, list);\r\n\r\n        // if all is ok, resolve now\r\n        if (summary.ready === true) {\r\n          resolve(new StatusSummary(list));\r\n          return;\r\n        }\r\n\r\n        // depending on the need, either reject/error (default) or resolve with false\r\n        switch (thisKs.settings.failure){\r\n          case FailReject: reject(summary); break;\r\n          case FailResolve: resolve(summary); break;\r\n          case FailSilent: return;\r\n        }\r\n      })\r\n    });\r\n      \r\n    return flattened;\r\n  }\r\n\r\n  public logStatusList(success: boolean, id: number, settings: Settings, statusList: Status[]): void {\r\n    console.log(LogPrefix + `#${id} `\r\n    + (settings.name !== DefaultName ? `\"${settings.name}\" ` : '')\r\n    + (success ? 'success!' : `couldn't complete because some conditions were not met. See details: `),\r\n     statusList);\r\n  }\r\n\r\n  private _conditionMaker = new ConditionMaker();\r\n\r\n  private static count = 0;\r\n}","import { Status } from '../status/status';\r\n\r\n\r\nexport function promiseBoolToStatus(boolPromise: Promise<boolean>): Promise<Status> {\r\n  return new Promise<Status>((resolve, reject) => {\r\n    boolPromise\r\n      .then(r => {\r\n        const result = r !== false;\r\n        resolve(new Status('bool-promise', result, 'from promise'));\r\n    })\r\n      .catch(reason => reject(reason));\r\n  });\r\n}\r\n","import { ConfigTagManager } from '../tags/config-tag-manager';\r\nimport { TagLoader } from '../tags/tag-loader';\r\nimport { Settings } from './settings';\r\nimport { TurnOn } from './turn-on';\r\n\r\nexport class TurnOnRoot {\r\n  \r\n  tagManager: ConfigTagManager;\r\n\r\n  loader: TagLoader;\r\n\r\n  constructor()\r\n  {\r\n    this.tagManager = new ConfigTagManager(this);\r\n    this.loader = new TagLoader(this.tagManager);\r\n    console.log('turnOn v0.3.0 active. It helps boot scripts when ready. Set window.debugTurnOn = true for debugging. https://go.2sxc.org/turnon')\r\n  }\r\n\r\n  /**\r\n   * Create a new turnOn object.\r\n   * Mainly useful in global scenarios, to give it a separate name\r\n   */\r\n  new(nameOrSettings?: Partial<Settings>): TurnOn {\r\n    return new TurnOn(nameOrSettings);\r\n  }\r\n\r\n  /**\r\n   * Basic debug\r\n   * @param args \r\n   */\r\n  dump(...args: any): void {\r\n    console.log(`turnOn dump() - total args: ${args?.length} - args dump:`, args);\r\n  }\r\n}","import { TurnOnRoot } from './turnOn/turn-on-root';\r\n\r\n// export * from './constants';\r\n// export * from './debug';\r\n\r\n// export * from './status';\r\n// export * from './conditions';\r\n// export * from './tags';\r\n// export * from './watch-promise';\r\n\r\n\r\nexport * from './window';\r\n\r\nif (!window.turnOn) window.turnOn = new TurnOnRoot();\r\n// const turnOn = window.turnOn as TurnOnRoot;\r\n\r\n// turnOn.loader.activateObserver();\r\n"],"names":["LogError","LogDebug","FailReject","DefaultName","interval","attempts","log","failure","name","ProgressError","createError","message","await","debug","run","progress","error","addContext","load","value","pretyped","configuration","JSON","parse","ex","ConfigHelper","stabilize","raw","startsWith","endsWith","requiresRaw","require","requires","Array","isArray","push","substring","length","args","logMode","data","undefined","settings","Settings","AttributeTurnOn","AttributeSkip","WindowName","LogPrefix","obj1","obj2","window","debugTurnOn","console","tag","config","turnOn","this","syncDom","getAttribute","setAttribute","currentSerialized","stringify","prog","success","result","parent","lastName","parts","partsFound","matchedKey","test","key","ExistsProgress","split","partName","current","match","i","root","tags","tryToLoadTag","node","attr","skip","add","ConfigTag","configTag","new","promise","then","checkExists","substr","contextData","fnScopeObject","fnArgs","argsData","mergeArgsWithDataAndContext","convertConfigToTurnOn","updateTags","forEach","t","queryForUnprocessedTags","tagManager","attributes","childList","subtree","scanInitialDom","activateObserver","document","documentElement","checkAndLoadChildren","children","querySelectorAll","observer","MutationObserver","mutations","m","type","from","addedNodes","filter","n","nodeType","observe","ready","details","stat","detectIfAllOk","Status","promiseType","checkFunction","lastStatus","innerCheck","check","asPromise","checkCondition","resolve","reject","setTimeout","Promise","createFnCondition","fn","toString","statusType","createNameCondition","exists","namedFnType","make","condition","fnCondition","nameCondition","statusOfName","createFunctionNameCondition","nameOrSettings","_conditionMaker","ConditionMaker","TurnOn","count","conditions","loadedCheckers","map","c","boolPromise","r","catch","reason","ConditionAsPromise","thisKs","instanceCount","all","list","summary","StatusSummary","logStatusList","id","statusList","ConfigTagManager","loader","TagLoader","dump","TurnOnRoot"],"sourceRoot":""}