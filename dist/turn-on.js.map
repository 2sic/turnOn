{"version":3,"file":"turn-on.js","mappings":"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","sources":["webpack://turn-on/./src/turnOn/settings.ts","webpack://turn-on/./src/configuration/configuration.ts","webpack://turn-on/./src/configuration/config-helper.ts","webpack://turn-on/./src/constants.ts","webpack://turn-on/./src/debug.ts","webpack://turn-on/./src/tags/config-tag.ts","webpack://turn-on/./src/conditions/exists-progress.ts","webpack://turn-on/./src/tags/config-tag-manager.ts","webpack://turn-on/./src/tags/config-to-turn-on.ts","webpack://turn-on/./src/tags/tag-loader.ts","webpack://turn-on/./src/status/status.ts","webpack://turn-on/./src/status/status-summary.ts","webpack://turn-on/./src/watch-promise/condition-as-promise.ts","webpack://turn-on/./src/conditions/condition-function.ts","webpack://turn-on/./src/conditions/condition-name.ts","webpack://turn-on/./src/conditions/condition-function-name.ts","webpack://turn-on/./src/conditions/condition-maker.ts","webpack://turn-on/./src/turnOn/turn-on.ts","webpack://turn-on/./src/watch-promise/promise-boolean-as-promise.ts","webpack://turn-on/./src/turnOn/turn-on-root.ts","webpack://turn-on/./src/index.ts"],"sourcesContent":["\r\n// this must be a simple const, otherwise the annotation below with typeof won't work\r\n// https://stackoverflow.com/questions/56263200/how-to-define-string-literal-union-type-from-constants-in-typescript\r\nexport const LogError = 'error';\r\nexport const LogDebug = 'debug';\r\nexport const LogSilent = 'silent';\r\n\r\nexport const FailSilent = 'silent';\r\nexport const FailResolve = 'resolve';\r\nexport const FailReject = 'reject';\r\nexport const DefaultName = 'turnOn';\r\n\r\nexport type LogMode = typeof LogError | typeof LogDebug | typeof LogSilent;\r\n\r\nexport class Settings {\r\n  /** the polling interval - defaults to 100 */\r\n  interval = 100;\r\n\r\n  /** polling attempts, defaults to 100 */\r\n  attempts = 100;\r\n \r\n  /** What to log into the console */\r\n  log: LogMode = LogError;\r\n\r\n  /**\r\n   * Failure mode, if by timeout it's not successful\r\n   * - reject (default)= use promise reject (which will throw an error if not handled)\r\n   * - resolve = use promise resolve and give a status back which says it's not complete\r\n   * - silent = don't complete the promise\r\n   */\r\n  failure: typeof FailReject | typeof FailResolve | typeof FailSilent = FailReject;\r\n\r\n  /** The name of this turnOn - to better track issues */\r\n  name = DefaultName;\r\n}","import { Settings } from '../turnOn/settings';\r\nexport const Progress1Loaded = '1-loaded';\r\nexport const Progress2Watching = '2-watching';\r\nexport const Progress3Running = '3-running';\r\nexport const Progress4Completed = '4-completed';\r\nexport const Progress9Cancelled = '9-cancelled';\r\nexport const ProgressError = '9-error';\r\n\r\nexport type TurnOnProgress = typeof Progress1Loaded | typeof Progress2Watching  | typeof Progress3Running | typeof Progress4Completed | typeof Progress9Cancelled | typeof ProgressError ;\r\n\r\nexport type AddContextLocation = true | false | 'data' | 'end';\r\n\r\nexport interface TurnOnConfigInternal {\r\n  /** Things to wait for - names on window (or sub-objects) or functions on window or sub-objects */\r\n  await: string[];\r\n\r\n  /** Special flag to log everything that's happening for extensive debugging */\r\n  debug: boolean;\r\n\r\n  /**\r\n   * What to run when all awaits have succeeded. \r\n   * The system will also wait for this to exist before it runs it. \r\n   */\r\n  run: string;\r\n\r\n  /** Information how far processing of this configuration has commenced */\r\n  progress: TurnOnProgress;\r\n\r\n  /** Possible error information */\r\n  error?: string;\r\n\r\n  /** Optional data to give the function once it starts */\r\n  data?: unknown;\r\n\r\n  /**\r\n   * Optional: data as args for the function\r\n   * New in v0.3.0.\r\n   * \r\n   * When provided, data will be ignored?\r\n   */\r\n  args?: unknown[];\r\n\r\n  addContext: AddContextLocation;\r\n\r\n  /** Settings used for this turn-on */\r\n  settings?: Settings\r\n}\r\n","import { TurnOnConfiguration } from '../tags/config-in-tag';\r\nimport { LogMode, Settings, LogError, LogDebug } from '../turnOn/settings';\r\nimport { Progress1Loaded, ProgressError, TurnOnConfigInternal, AddContextLocation } from './configuration';\r\n\r\nexport class ConfigHelper {\r\n\r\n  /**\r\n   * Create a configuration object which just contains an error\r\n   */\r\n  static createError(message: string): TurnOnConfigInternal {\r\n    const result: TurnOnConfigInternal = {\r\n      await: [],\r\n      debug: false,\r\n      run: '',\r\n      progress: ProgressError,\r\n      error: message,\r\n      addContext: false,\r\n    };\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Load a configuration from a string usually from an Html attribute\r\n   */\r\n  static load(value: string): TurnOnConfigInternal {\r\n    let pretyped: TurnOnConfiguration;\r\n    try {\r\n      pretyped = JSON.parse(value);\r\n    }\r\n    catch (ex) {\r\n      return ConfigHelper.createError(`detected configuration but cannot parse to json.`);\r\n    }\r\n\r\n    let configuration: TurnOnConfigInternal;\r\n    try {\r\n      configuration = ConfigHelper.stabilize(pretyped);\r\n    }\r\n    catch (ex) { \r\n      return ConfigHelper.createError(`Error loading configuration, reason unknown.`)\r\n    }\r\n  \r\n    return configuration;\r\n  }\r\n\r\n  /**\r\n   * Import a raw configuration and make sure it's fully compliant\r\n   */\r\n  private static stabilize(raw: TurnOnConfiguration): TurnOnConfigInternal {\r\n    // 1. Start with the run command - ensure it's there and correct\r\n    if(!raw) return ConfigHelper.createError('No turn-on config found to process');\r\n    if(!raw.run) return ConfigHelper.createError(`Config didn't contain 'run' - it's required.`);\r\n    if(!raw.run.startsWith('window')) return ConfigHelper.createError(`run command must start with 'window.' but is:` + raw.run);\r\n    if(!raw.run.endsWith('()')) return ConfigHelper.createError(`run must be a function name and end with () but it's:` + raw.run);\r\n  \r\n    // 2. Get the requires/awaits\r\n    const requiresRaw = raw.require ?? raw.await;\r\n    const requires = Array.isArray(requiresRaw) \r\n          ? requiresRaw\r\n          : requiresRaw\r\n            ? [requiresRaw]\r\n            : [];\r\n  \r\n    // also always await the run command, but without the () as it shouldn't be called to detect if it's ready    \r\n    requires.push(raw.run.substring(0, raw.run.length-2));\r\n  \r\n    // 3. Get the args and ensure it's an array if given\r\n    if(raw.args && !Array.isArray(raw.args))\r\n      return ConfigHelper.createError('args must be an array if given');\r\n\r\n    // 4. Get the log mode\r\n    const logMode: LogMode = (raw?.debug ?? false) ? LogDebug : LogError;\r\n\r\n    const addContext = raw.addContext != null\r\n      ? raw.addContext\r\n      : raw.args\r\n        ? false\r\n        : true;\r\n\r\n    const stable: TurnOnConfigInternal = {\r\n      await: requires,\r\n      debug: raw.debug ?? false,\r\n      run: raw.run,\r\n      progress: Progress1Loaded,\r\n      data: raw.data || { }, // give empty object so a developer can see this would exist as an option\r\n      args: raw.args,\r\n      settings: { ...new Settings(), log: logMode, ...raw.settings },\r\n      addContext,\r\n    }\r\n    return stable;\r\n  }\r\n}","\r\nexport const AttributeTurnOn = 'turn-on';\r\nexport const AttributeSkip = 'turn-on-skip';\r\n\r\nexport const WindowName = 'window';\r\n\r\nexport const LogPrefix = 'turn-on: ';","\r\n// const debug = true;\r\n\r\nimport { LogPrefix } from './constants';\r\n\r\nexport function log(message: string, obj1?: unknown, obj2?: unknown): void {\r\n  if(!window.debugTurnOn) return;\r\n  if(obj2) console.log(LogPrefix + message, obj1, obj2);\r\n  else if(obj1)  console.log(LogPrefix + message, obj1);\r\n  else console.log(LogPrefix + message);\r\n}","import { log } from '../debug';\r\nimport { TurnOn } from '../turnOn/turn-on';\r\nimport { ProgressError, TurnOnConfigInternal, TurnOnProgress } from '../configuration/configuration';\r\nimport { AttributeSkip, AttributeTurnOn } from '../constants';\r\n\r\n\r\nexport class ConfigTag {\r\n\r\n  constructor(\r\n    public tag: HTMLElement,\r\n    public config: TurnOnConfigInternal,\r\n    public turnOn?: TurnOn\r\n  ) \r\n  { \r\n    this.syncDom();\r\n  }\r\n\r\n  syncDom(): void {\r\n    log('syncDom', this);\r\n    const tag = this.tag;\r\n    // set skip if missing and update json in html if not current\r\n    // Do these checks to avoid to many DOM changes\r\n    if(!tag.getAttribute(AttributeSkip)) tag.setAttribute(AttributeSkip, \"skip\");\r\n    const currentSerialized = JSON.stringify(this.config);\r\n    if(tag.getAttribute(AttributeTurnOn) !== currentSerialized)\r\n      tag.setAttribute(AttributeTurnOn, currentSerialized);\r\n  }\r\n\r\n  progress(prog: TurnOnProgress): void {\r\n    this.config.progress = prog;\r\n    this.syncDom();\r\n  }\r\n\r\n  error(message: string): void {\r\n    this.config.progress = ProgressError;\r\n    this.config.error = message;\r\n    this.syncDom();\r\n    throw this.config.error;\r\n  }\r\n}","import { WindowName } from '../constants';\r\n\r\n\r\n/**\r\n * Internal Class which will check if a object path like `window.something.other` exists and report back how much of it works.\r\n */\r\nexport class ExistsProgress {\r\n  constructor(\r\n    /** true/false if it succeeded till the end */\r\n    public success: boolean,\r\n\r\n    /** resulting object or method it would call */\r\n    public result: unknown,\r\n\r\n    /** The parent of the resulting object - in case the result was a method which needs to be rebound */\r\n    public parent: unknown,\r\n\r\n    /** name of the last element found - important if the last thing is a function*/\r\n    public lastName: string,\r\n\r\n    /** Amount of parts in the full identifier */\r\n    public parts: number,\r\n\r\n    /** Amount of parts found */\r\n    public partsFound: number,\r\n\r\n    /** Part-path which already worked */\r\n    public matchedKey: string,\r\n  ) { }\r\n\r\n  static test(key: string): ExistsProgress {\r\n    if(!key) return new ExistsProgress(true, null, null, null, 0, 0, \"\");\r\n\r\n    const parts = key.split('.');\r\n    if(parts[0] !== WindowName) throw `Key must start with '${WindowName}.' but it's '${key}'`;\r\n\r\n    // Only contains window, stop here\r\n    if (parts.length == 1) return new ExistsProgress(true, window, null, WindowName, 1, 1, WindowName);\r\n\r\n    let current = window as any;\r\n    let parent = null as any;\r\n    let match = WindowName;\r\n    let partName: string;\r\n    for (let i = 1; i < parts.length; i++) {\r\n      partName = parts[i];\r\n      parent = current;\r\n      current = current[partName];\r\n      // found, so let's add to list of successful matches\r\n      match += '.' + partName;\r\n\r\n      // if node not found, stop checking\r\n      if (!current) return new ExistsProgress(false, null, parent, partName, parts.length, i, match);\r\n    }\r\n    return new ExistsProgress(true, current, parent, partName, parts.length, parts.length, match);\r\n  }\r\n}","import { ConfigHelper } from '../configuration/config-helper';\r\nimport { ProgressError, TurnOnConfigInternal } from '../configuration/configuration';\r\nimport { AttributeSkip, AttributeTurnOn } from '../constants';\r\nimport { ConfigTag } from './config-tag';\r\nimport { log } from '../debug';\r\nimport { convertConfigToTurnOn } from './config-to-turn-on';\r\nimport { TurnOnRoot } from '../turnOn/turn-on-root';\r\n\r\n\r\nexport class ConfigTagManager {\r\n  \r\n  public tags = new Array<ConfigTag>();\r\n\r\n  constructor(public root: TurnOnRoot) {}\r\n\r\n\r\n  tryToLoadTag(node: HTMLElement): void {\r\n    // Get config and skip if not relevant, or skip if already marked as in the queue\r\n    const attr = node?.getAttribute?.(AttributeTurnOn);\r\n    if(!attr) return;\r\n    const skip = node?.getAttribute?.(AttributeSkip);\r\n    log('skip', skip);\r\n    if(skip) return log('skip');\r\n\r\n    log('attr', attr);\r\n    const config = ConfigHelper.load(attr);\r\n    if(config.progress === ProgressError) {\r\n      console.error(config.error, node, attr);\r\n      return;\r\n    }\r\n    log('stable config')\r\n    this.add(node, config);\r\n  }\r\n  \r\n  /**\r\n   * \r\n   */\r\n  add(node: HTMLElement, config: TurnOnConfigInternal): void {\r\n    log('add', node, config);\r\n    const tag = new ConfigTag(node, config);\r\n    this.tags.push(tag);\r\n    convertConfigToTurnOn(this.root, tag);\r\n  }\r\n\r\n  updateTags(): void {\r\n    log(`updateTags: ${this.tags.length}`);\r\n    this.tags.forEach((t) => t.syncDom())\r\n  }\r\n\r\n}","import { ExistsProgress } from '../conditions/exists-progress';\r\nimport { ContextData } from './context-data';\r\nimport { Progress2Watching, Progress3Running, Progress4Completed, TurnOnConfigInternal } from '../configuration/configuration';\r\nimport { ConfigTag } from './config-tag';\r\nimport { Status } from '../status/status';\r\nimport { log } from '../debug';\r\nimport { TurnOnRoot } from '../turnOn/turn-on-root';\r\n\r\n/**\r\n * \r\n */\r\nexport function convertConfigToTurnOn(root: TurnOnRoot, configTag: ConfigTag): Promise<Status> {\r\n  const config = configTag.config;\r\n  log('convert to turnon');\r\n  const turnOn = root.new(config.settings);\r\n  config.settings = turnOn.settings;\r\n  const promise = turnOn.await(config.await);\r\n  configTag.progress(Progress2Watching);\r\n\r\n  promise.then(() => {\r\n    const run = config.run;\r\n    log('turn on success - will try to run ' + run);\r\n    configTag.progress(Progress3Running);\r\n    if(!run.endsWith('()')) {\r\n      configTag.error(`run should end with () but doesn't - can't continue`);\r\n      return;\r\n    }\r\n\r\n    // check exists without trailing \"()\"\"\r\n    const checkExists = ExistsProgress.test(run.substr(0, run.length - 2));\r\n\r\n    // if node not found or it's not a function, stop checking\r\n    if (!checkExists.success) {\r\n      configTag.error(`Tried to find object parts for ${checkExists.matchedKey} but didn't get anything.`);\r\n      return;\r\n    }\r\n    if (typeof(checkExists.result) !== 'function') {\r\n      configTag.error(`Got ${checkExists.partsFound} but it's not a function`);\r\n      return;\r\n    }\r\n\r\n    // now run it!\r\n    // Special: we can't just run the function we got back\r\n    // because that loses the `this`. So we must run it as a property of the parent\r\n    const data = config.data;\r\n    const contextData: ContextData = { tag: configTag.tag, config: config };\r\n    const fnScopeObject = checkExists.parent as any;\r\n\r\n    // New v0.3.0: if we have args, use them\r\n    if (config.args) {\r\n      const fnArgs = mergeArgsWithDataAndContext(config, contextData);\r\n      fnScopeObject[checkExists.lastName](...fnArgs);\r\n    }\r\n    // Classic run with data only\r\n    else {\r\n      fnScopeObject[checkExists.lastName](data, contextData);\r\n    }\r\n\r\n    configTag.progress(Progress4Completed);\r\n  });\r\n  return promise;\r\n}\r\n\r\nfunction mergeArgsWithDataAndContext(config: TurnOnConfigInternal, contextData: ContextData): unknown[] {\r\n  const data = config.data;\r\n  let fnArgs = config.args;\r\n\r\n      \r\n  // if we have data, prepend it to the args, optionally mix with context\r\n  if (config.data != undefined) {\r\n    // merge data with context if addContext is set to `data`\r\n    const argsData = config.addContext === 'data' && (typeof data === 'object' && !Array.isArray(data) && data !== null)\r\n      ? { ...contextData, ...data }\r\n      : data;\r\n    fnArgs = [argsData, ...fnArgs];\r\n  }\r\n\r\n  // with or without data - if we should add context to end, do so\r\n  if (config.addContext === 'end')\r\n    fnArgs = [...fnArgs, contextData];\r\n\r\n  return fnArgs;\r\n}","import { AttributeSkip, AttributeTurnOn } from '../constants';\r\nimport { log } from '../debug';\r\nimport { ConfigTagManager } from './config-tag-manager';\r\n\r\n\r\nconst queryForUnprocessedTags = `[${AttributeTurnOn}]:not([${AttributeSkip}])`;\r\n\r\nconst ELEMENT_NODE = 1; // see https://developer.mozilla.org/en-US/docs/Web/API/Node\r\n\r\n/**\r\n * In charge of loading all turn-on tags from the DOM, both at first load as well as on DOM changes\r\n */\r\nexport class TagLoader {\r\n\r\n  /** Options for the observer (which mutations to observe) */\r\n  public config : MutationObserverInit = { \r\n    attributes: false, \r\n    childList: true, \r\n    subtree: true \r\n  };\r\n\r\n  /** The observer, in case we need to debug */\r\n  public observer: MutationObserver;\r\n\r\n  constructor(public tagManager: ConfigTagManager) {\r\n    this.scanExistingDom();\r\n    this.activateObserver();\r\n  }\r\n\r\n  public scanExistingDom(): void {\r\n    log('scanExistingDom');\r\n    if(document.documentElement)\r\n      this.checkAndLoadChildren(document.documentElement);\r\n  }\r\n\r\n  private checkAndLoadChildren(parent: HTMLElement) {\r\n    log('checkAndLoadChildren', parent);\r\n    if(!parent?.children?.length) return;\r\n    const tags = parent.querySelectorAll(queryForUnprocessedTags);\r\n    tags.forEach((t: HTMLElement) => this.tagManager.tryToLoadTag(t));\r\n  }\r\n\r\n  public activateObserver(): void {\r\n    log('activateObserver');\r\n  \r\n    this.observer = new MutationObserver((mutations) => {\r\n      log('mutations detected', mutations);\r\n      // Loop through each changed item, check if it's something we want to initialize\r\n      mutations.forEach((m) => {\r\n        // Nodes added - let's check if it is a turn-on\r\n        if(m.type != 'childList') return;\r\n        log('childList changes');\r\n\r\n        Array.from(m.addedNodes)\r\n          // nodes can contain text and stuff as well, so we must filter first\r\n          .filter(n => n.nodeType === ELEMENT_NODE)\r\n          .forEach((node: HTMLElement) => {\r\n            if(node?.getAttribute?.(AttributeTurnOn))\r\n              this.tagManager.tryToLoadTag(node);\r\n            else \r\n              this.checkAndLoadChildren(node);\r\n          });\r\n      });\r\n    });\r\n  \r\n    // observe document for tags which include this. ATM don't observe header\r\n    this.observer.observe(document.documentElement, this.config);\r\n  }\r\n}\r\n","\r\nconst nameNotDefined = 'not set';\r\n\r\nexport class Status {\r\n  constructor(\r\n    /** The status type, like window-key, function, summary etc. */\r\n    public type: string,\r\n\r\n    /** Status if the check has been successful */\r\n    public ready: boolean,\r\n\r\n    /** Status message if provided */\r\n    public message: string, \r\n    \r\n    /** name of this status, to better point to which rule failed */\r\n    public name: string = nameNotDefined,\r\n    \r\n    /** result of a check - in some cases needed for next steps */\r\n    public result?: unknown\r\n    ) {\r\n  }\r\n\r\n  /** Amount of attempts tried till this  */\r\n  attempts? = 0;\r\n\r\n}\r\n","import { Status } from './status';\r\n\r\nexport class StatusSummary extends Status {\r\n\r\n  constructor(details: Status[]) {\r\n    // no details provided, then assume ok\r\n    if (!details) details = [];\r\n\r\n    const ready = detectIfAllOk(details);\r\n\r\n    const message = details.length === 0\r\n      ? 'no conditions provided'\r\n      : ready\r\n        ? 'all ok'\r\n        : 'some conditions did not complete';\r\n    super('summary', ready, message, 'Summary');\r\n    this.details = details;\r\n  }\r\n\r\n  /** Details of each of the status received */\r\n  details: Status[]\r\n}\r\n\r\nfunction detectIfAllOk(details: Status[]) {\r\n  // some kind of error appeared, shouldn't be ok\r\n  if (!Array.isArray(details)) return false;\r\n\r\n  // count if all details have a ready-state\r\n  return (details.filter(stat => stat.ready).length == details.length)\r\n}","import { Status } from '../status/status';\r\nimport { Settings } from '../turnOn/settings';\r\n\r\n\r\nconst promiseType = 'promise';\r\nexport class ConditionAsPromise {\r\n\r\n  public settings: Settings;\r\n\r\n  constructor(checkFunction: () => Status, settings: Settings) {\r\n    this.innerCheck = checkFunction;\r\n    this.settings = settings;\r\n  }\r\n\r\n  public lastStatus: Status = new Status(promiseType, false, 'condition not checked yet');\r\n  public attempts = 0;\r\n\r\n  /**\r\n   * Dummy innerCheck function - should be replaced in the constructor\r\n   */\r\n  public innerCheck(): Status { return new Status(promiseType, true, 'no condition defined') }\r\n\r\n  public check(): Status {\r\n    if (this.lastStatus.ready === true) return this.lastStatus;\r\n\r\n    // check and store\r\n    this.lastStatus = this.innerCheck();\r\n\r\n    return this.lastStatus;\r\n  }\r\n\r\n  public asPromise(): Promise<Status> {\r\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n    const parent = this;\r\n    const checkCondition = function(resolve: (value: Status) => void, reject: (reason: unknown | null) => void) {\r\n      // If the condition is met, we're done! \r\n      const result = parent.check();\r\n\r\n      // if all is ok (true) then complete the promise\r\n      if(result.ready === true) {\r\n        resolve( { ...result, attempts: parent.attempts });\r\n        return;\r\n      }\r\n\r\n      if(parent.attempts++ >= parent.settings.attempts) {\r\n        resolve({ ...result, message: 'tried up to max attempts: ' + result.message, attempts: parent.attempts });\r\n        return;\r\n      }\r\n\r\n      // If the condition isn't met but the timeout hasn't elapsed, go again\r\n      setTimeout(checkCondition, parent.settings.interval, resolve, reject);\r\n    };\r\n\r\n    return new Promise(checkCondition)\r\n  }\r\n}\r\n","import { Status } from '../status/status';\r\nimport { Condition } from './condition-type';\r\n\r\n/**\r\n * Create a condition based on a function which will be polled till it returns truthy\r\n */\r\nexport function createFnCondition(fn: () => boolean): Condition {\r\n  let name = fn.toString();\r\n  if (name && name.length > 25) name = name.substr(0, 25);\r\n  return () => { \r\n    return new Status('fn', fn(), '', name);\r\n  }\r\n}","import { WindowName } from '../constants';\r\nimport { Status } from '../status/status';\r\nimport { Condition } from './condition-type';\r\nimport { ExistsProgress } from './exists-progress';\r\n\r\nconst statusType = 'window-key';\r\n\r\n/**\r\n * Create a checker which verifies if a key or key-sequence on window exists\r\n */\r\nexport function createNameCondition(key: string): Condition {\r\n  // empty-ish strings - always say it's done\r\n  if (!key) return () => new Status(statusType, true, 'empty key', key);\r\n  if (key === WindowName) return () => new Status(statusType, true, 'no keys except maybe windows found', key);\r\n\r\n  return () => {\r\n    const exists = ExistsProgress.test(key);\r\n    if(exists.success) return new Status(statusType, true, 'all keys matched', key, exists.result);\r\n    return new Status(statusType, false, `Not all keys matched yet. So far '${exists.matchedKey}' worked.`, key);\r\n  }\r\n}","import { createNameCondition } from './condition-name';\r\nimport { createFnCondition } from './condition-function';\r\nimport { Condition } from './condition-type';\r\n\r\nconst namedFnType = 'named fn';\r\n\r\n/**\r\n * Create a condition which waits for a function to exist, and then polls it till the result is ok.\r\n */\r\nexport function createFunctionNameCondition(key: string): Condition {\r\n  if(!key.endsWith('()')) throw `Tried to create Function-Name condition but that requires it to end with (), got ${key}`;\r\n\r\n  const keyWithoutBrackets = key.substring(0, key.length - 2);\r\n  let fnCondition: Condition;\r\n  const nameCondition = createNameCondition(keyWithoutBrackets);\r\n  return () => {\r\n\r\n    // As long as the name doesn't exist, check that and return that status\r\n    // But only do this till we have the fnCondition once, then skip\r\n    if(!fnCondition) {\r\n      const statusOfName = nameCondition();\r\n      if(!statusOfName.ready) return { ...statusOfName, type: namedFnType} ;\r\n\r\n      // Check if we really got a function - if not, assume all is ok and don't try to call\r\n      if(typeof(statusOfName.result) !== 'function') return { ...statusOfName, type: namedFnType };\r\n      \r\n      // Create the function-condition to use from now on. \r\n      fnCondition = createFnCondition(statusOfName.result as () => boolean);\r\n    }\r\n\r\n    // once the name exists, try to get the function\r\n    return { ...fnCondition(), type: namedFnType };\r\n  }\r\n}","import { createFnCondition } from './condition-function';\r\nimport { createFunctionNameCondition } from './condition-function-name';\r\nimport { createNameCondition } from './condition-name';\r\nimport { Condition, ConditionRaw } from './condition-type';\r\n\r\n/**\r\n * Internal class to generate is-it-ready checkers\r\n */\r\nexport class ConditionMaker {\r\n\r\n  /**\r\n   * Make a new condition checker\r\n   */\r\n  public make(condition: ConditionRaw): Condition {\r\n    if (typeof(condition) === 'function')\r\n      return createFnCondition(condition);\r\n    \r\n    if (typeof(condition) === 'string')\r\n      return condition.endsWith('()')\r\n        ? createFunctionNameCondition(condition)\r\n        : createNameCondition(condition);\r\n  }\r\n}","import { DefaultName, FailReject, FailResolve, FailSilent, LogDebug, LogSilent, Settings } from './settings';\r\nimport { promiseBoolToStatus } from '../watch-promise/promise-boolean-as-promise';\r\nimport { LogPrefix } from '../constants';\r\nimport { Status } from '../status/status';\r\nimport { StatusSummary } from '../status/status-summary';\r\nimport { ConditionRaw } from '../conditions/condition-type';\r\nimport { ConditionAsPromise } from '../watch-promise/condition-as-promise';\r\nimport { ConditionMaker } from '../conditions/condition-maker';\r\n\r\nexport class TurnOn {\r\n\r\n  /** \r\n   * The settings for this turnOn\r\n   */\r\n  public settings;\r\n\r\n  /**\r\n   * Constructor with optional settings\r\n   */\r\n  constructor(nameOrSettings?: Partial<Settings> | string) {\r\n    // Handle case where only a name is provided\r\n    if (typeof nameOrSettings === 'string') {\r\n      nameOrSettings = {\r\n        name: nameOrSettings\r\n      } as Partial<Settings>;\r\n    }\r\n\r\n    // merge settings with default settings ??? not sure why\r\n    if (nameOrSettings)\r\n      this.settings = { ...new Settings(), ...nameOrSettings };\r\n\r\n    TurnOn.count++;\r\n  }\r\n\r\n  /**\r\n   * Create a new turnOn object.\r\n   * Mainly useful in global scenarios, to give it a separate name\r\n   */\r\n  new(nameOrSettings?: Partial<Settings>): TurnOn {\r\n    return new TurnOn(nameOrSettings);\r\n  }\r\n\r\n  /**\r\n   * Old call, renamed to `require` in v0.2\r\n   * @param conditions \r\n   * @returns \r\n   * @deprecated in v0.2, but will probably remain forever, just not documented any more.\r\n   */\r\n  public await(conditions: ConditionRaw | ConditionRaw[]): Promise<Status> { \r\n    return this.require(conditions);\r\n  }\r\n\r\n  /**\r\n   * Require a set of conditions to be met before executing run.\r\n   * @param conditions \r\n   * @returns \r\n   */\r\n  public require(conditions: ConditionRaw | ConditionRaw[]): Promise<Status> {\r\n\r\n    // re-wrap to ensure we always work with an array\r\n    const conditionsArray = (Array.isArray(conditions)) ? conditions : [conditions];\r\n\r\n    // convert conditions to promises\r\n    const loadedCheckers = conditionsArray.map(c => {\r\n      // do this for non-promise conditions\r\n      if (Promise.resolve(c as unknown) === c) {\r\n        return promiseBoolToStatus(c);\r\n      } else {\r\n        const condition = this._conditionMaker.make(c);\r\n        const loaded = new ConditionAsPromise(condition, this.settings);\r\n        return loaded.asPromise();  \r\n      }\r\n    });\r\n\r\n    // keep the current turnOn-object for reference in methods\r\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n    const thisKs = this;\r\n\r\n    // keep count as it was on start, to ensure it doesn't change any more till we log the error\r\n    const instanceCount = TurnOn.count;\r\n\r\n    const flattened = new Promise<StatusSummary>((resolve, reject) => { \r\n      // return a single promise for all inner promises which either fail or resolve\r\n      Promise.all(loadedCheckers).then(list => {\r\n\r\n        // get summary of all details infos\r\n        const summary = new StatusSummary(list);\r\n\r\n        // by default, log details about what failed\r\n        if (window.debugTurnOn || thisKs.settings.log === LogDebug || (!summary.ready && thisKs.settings.log !== LogSilent))\r\n          thisKs.logStatusList(summary.ready, instanceCount, thisKs.settings, list);\r\n\r\n        // if all is ok, resolve now\r\n        if (summary.ready === true) {\r\n          resolve(new StatusSummary(list));\r\n          return;\r\n        }\r\n\r\n        // depending on the need, either reject/error (default) or resolve with false\r\n        switch (thisKs.settings.failure){\r\n          case FailReject: reject(summary); break;\r\n          case FailResolve: resolve(summary); break;\r\n          case FailSilent: return;\r\n        }\r\n      })\r\n    });\r\n      \r\n    return flattened;\r\n  }\r\n\r\n  public logStatusList(success: boolean, id: number, settings: Settings, statusList: Status[]): void {\r\n    console.log(LogPrefix + `#${id} `\r\n    + (settings.name !== DefaultName ? `\"${settings.name}\" ` : '')\r\n    + (success ? 'success!' : `couldn't complete because some conditions were not met. See details: `),\r\n     statusList);\r\n  }\r\n\r\n  private _conditionMaker = new ConditionMaker();\r\n\r\n  private static count = 0;\r\n}","import { Status } from '../status/status';\r\n\r\n\r\nexport function promiseBoolToStatus(boolPromise: Promise<boolean>): Promise<Status> {\r\n  return new Promise<Status>((resolve, reject) => {\r\n    boolPromise\r\n      .then(r => {\r\n        const result = r !== false;\r\n        resolve(new Status('bool-promise', result, 'from promise'));\r\n    })\r\n      .catch(reason => reject(reason));\r\n  });\r\n}\r\n","import { ConfigTagManager } from '../tags/config-tag-manager';\r\nimport { TagLoader } from '../tags/tag-loader';\r\nimport { Settings } from './settings';\r\nimport { TurnOn } from './turn-on';\r\n\r\nexport class TurnOnRoot {\r\n  \r\n  tagManager: ConfigTagManager;\r\n\r\n  loader: TagLoader;\r\n\r\n  constructor()\r\n  {\r\n    this.tagManager = new ConfigTagManager(this);\r\n    this.loader = new TagLoader(this.tagManager);\r\n    console.log('turnOn v0.3.0 active - it will help boot scripts when ready - set window.debugTurnOn = true for debugging')\r\n  }\r\n\r\n  /**\r\n   * Create a new turnOn object.\r\n   * Mainly useful in global scenarios, to give it a separate name\r\n   */\r\n  new(nameOrSettings?: Partial<Settings>): TurnOn {\r\n    return new TurnOn(nameOrSettings);\r\n  }\r\n}","import { TurnOnRoot } from './turnOn/turn-on-root';\r\n\r\n// export * from './constants';\r\n// export * from './debug';\r\n\r\n// export * from './status';\r\n// export * from './conditions';\r\n// export * from './tags';\r\n// export * from './watch-promise';\r\n\r\n\r\nexport * from './window';\r\n\r\nif (!window.turnOn) window.turnOn = new TurnOnRoot();\r\n// const turnOn = window.turnOn as TurnOnRoot;\r\n\r\n// turnOn.loader.activateObserver();\r\n"],"names":["LogError","LogDebug","FailReject","DefaultName","interval","attempts","log","failure","name","ProgressError","createError","message","await","debug","run","progress","error","addContext","load","value","pretyped","configuration","JSON","parse","ex","ConfigHelper","stabilize","raw","startsWith","endsWith","requiresRaw","require","requires","Array","isArray","push","substring","length","args","logMode","data","settings","Settings","AttributeTurnOn","AttributeSkip","WindowName","LogPrefix","obj1","obj2","window","debugTurnOn","console","tag","config","turnOn","this","syncDom","getAttribute","setAttribute","currentSerialized","stringify","prog","success","result","parent","lastName","parts","partsFound","matchedKey","test","key","ExistsProgress","split","partName","current","match","i","root","tags","tryToLoadTag","node","attr","skip","add","ConfigTag","configTag","new","promise","then","checkExists","substr","contextData","fnScopeObject","fnArgs","undefined","argsData","mergeArgsWithDataAndContext","convertConfigToTurnOn","updateTags","forEach","t","queryForUnprocessedTags","tagManager","attributes","childList","subtree","scanExistingDom","activateObserver","document","documentElement","checkAndLoadChildren","children","querySelectorAll","observer","MutationObserver","mutations","m","type","from","addedNodes","filter","n","nodeType","observe","ready","details","stat","detectIfAllOk","Status","promiseType","checkFunction","lastStatus","innerCheck","check","asPromise","checkCondition","resolve","reject","setTimeout","Promise","createFnCondition","fn","toString","statusType","createNameCondition","exists","namedFnType","make","condition","fnCondition","nameCondition","statusOfName","createFunctionNameCondition","nameOrSettings","_conditionMaker","ConditionMaker","TurnOn","count","conditions","loadedCheckers","map","c","boolPromise","r","catch","reason","ConditionAsPromise","thisKs","instanceCount","all","list","summary","StatusSummary","logStatusList","id","statusList","ConfigTagManager","loader","TagLoader","TurnOnRoot"],"sourceRoot":""}