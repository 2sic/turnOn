{"version":3,"sources":["webpack://turn-on/./src/constants.ts","webpack://turn-on/./src/debug.ts","webpack://turn-on/./src/status/status.ts","webpack://turn-on/./src/status/status-summary.ts","webpack://turn-on/./src/conditions/condition-maker.ts","webpack://turn-on/./src/configuration/configuration.ts","webpack://turn-on/./src/tags/config-tag.ts","webpack://turn-on/./src/turnOn/settings.ts","webpack://turn-on/./src/configuration/config-helper.ts","webpack://turn-on/./src/tags/config-tag-manager.ts","webpack://turn-on/./src/tags/config-to-turn-on.ts","webpack://turn-on/./src/tags/tag-loader.ts","webpack://turn-on/./src/watch-promise/condition-as-promise.ts","webpack://turn-on/./src/turnOn/turn-on.ts","webpack://turn-on/./src/watch-promise/promise-boolean-as-promise.ts","webpack://turn-on/./src/turnOn/turn-on-root.ts","webpack://turn-on/./src/index.ts","webpack://turn-on/webpack/bootstrap","webpack://turn-on/webpack/runtime/define property getters","webpack://turn-on/webpack/runtime/hasOwnProperty shorthand","webpack://turn-on/webpack/startup"],"names":["attrConfig","attrSkip","log","message","obj1","obj2","console","ready","name","attempts","details","Array","isArray","filter","stat","length","detectIfAllOk","Status","make","condition","this","fnChecker","keyChecker","fn","toString","substr","key","parts","split","shift","parent","window","match","i","part","ProgressError","tag","config","turnOn","syncDom","getAttribute","setAttribute","currentSerialized","JSON","stringify","progress","prog","error","FailReject","DefaultName","interval","failure","createError","await","run","load","value","pretyped","configuration","parse","ex","ConfigHelper","stabilize","raw","startsWith","endsWith","awaits","push","substring","data","root","tags","tryToLoadTag","node","attr","skip","add","ConfigTag","new","then","current","convertConfigToTurnOn","updateTags","forEach","t","attributes","childList","subtree","tagManager","scanExistingDom","document","querySelectorAll","activateObserver","MutationObserver","mutations","m","type","addedNodes","observe","documentElement","checkFunction","settings","lastStatus","innerCheck","check","asPromise","checkCondition","resolve","reject","result","setTimeout","Promise","nameOrSettings","Settings","_conditionMaker","ConditionMaker","TurnOn","count","conditions","loadedCheckers","map","c","boolPromise","r","catch","reason","ConditionAsPromise","thisKs","instanceCount","all","list","summary","StatusSummary","logStatusList","id","statusList","ConfigTagManager","loader","TagLoader","win","TurnOnRoot","__webpack_module_cache__","__webpack_require__","moduleId","exports","module","__webpack_modules__","d","definition","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call"],"mappings":"yHACO,IAAMA,EAAa,UACbC,EAAW,eCCjB,SAASC,EAAIC,EAAiBC,EAAgBC,GAEhDA,EAAMC,QAAQJ,IAAI,YAAcC,EAASC,EAAMC,GAC1CD,EAAOE,QAAQJ,IAAI,YAAcC,EAASC,GAC7CE,QAAQJ,IAAI,YAAcC,GCNjC,I,EACA,EACE,SAGSI,EAGAJ,EAGAK,QAAA,IAAAA,MAXY,WAKZ,KAAAD,QAGA,KAAAJ,UAGA,KAAAK,OAIT,KAAAC,SAAY,G,kcCbd,cAEE,WAAYC,GAAZ,WAEOA,IAASA,EAAU,IAExB,IAAMH,EAeV,SAAuBG,GAErB,QAAKC,MAAMC,QAAQF,IAGXA,EAAQG,QAAO,SAAAC,GAAQ,OAAAA,EAAKP,SAAOQ,QAAUL,EAAQK,OApB7CC,CAAcN,GAEtBP,EAA6B,IAAnBO,EAAQK,OACpB,yBACAR,EACE,SACA,mC,OACN,cAAMA,EAAOJ,EAAS,YAAU,MAC3BO,QAAUA,E,EAKnB,OAnBmC,OAmBnC,EAnBA,CAAmCO,GCGnC,2BA4DA,OAvDS,YAAAC,KAAP,SAAYC,GACV,MAA0B,mBAAhB,EACDC,KAAKC,UAAUF,GAEE,iBAAhB,EACDC,KAAKE,WAAWH,QADzB,GAMF,YAAAE,UAAA,SAAUE,GACR,IAAIf,EAAOe,EAAGC,WAEd,OADIhB,GAAQA,EAAKO,OAAS,KAAIP,EAAOA,EAAKiB,OAAO,EAAG,KAC7C,WACL,MAAO,CACLjB,KAAI,EACJD,MAAOgB,IACPpB,QAAS,MASf,YAAAmB,WAAA,SAAWI,GAET,IAAKA,EAAK,OAAO,WAAM,WAAIT,GAAO,EAAM,YAAaS,IAErD,IAAMC,EAAQD,EAAIE,MAAM,KAIxB,OAHID,EAAMZ,OAAS,GAAiB,UAAZY,EAAM,IAC5BA,EAAME,QAEY,GAAhBF,EAAMZ,OAAoB,WAAM,WAAIE,GAAO,EAAM,qCAAsCS,IAEpF,WAIL,IAFA,IAAII,EAASC,OACTC,EAAQ,SACHC,EAAI,EAAGA,EAAIN,EAAMZ,OAAQkB,IAAK,CACrC,IAAMC,EAAOP,EAAMM,GAGnB,KAFAH,EAASA,EAAOI,IAEH,MAMb,GAHAF,GAAS,IAAME,EAGXD,GAAKN,EAAMZ,OAAS,EAAG,OAAO,IAAIE,GAAO,EAAM,mBAAoBS,GAEzE,OAAO,IAAIT,GAAO,EAAO,qCAAqCe,EAAK,YAAaN,KAGtF,EA5DA,GCDaS,EAAgB,UCE7B,aAEE,WACSC,EACAC,EACAC,GAFA,KAAAF,MACA,KAAAC,SACA,KAAAC,SAGPlB,KAAKmB,UAyBT,OAtBE,YAAAA,QAAA,WACErC,EAAI,UAAWkB,MACf,IAAMgB,EAAMhB,KAAKgB,IAGbA,EAAII,aAAavC,IAAWmC,EAAIK,aAAaxC,EAAU,QAC3D,IAAMyC,EAAoBC,KAAKC,UAAUxB,KAAKiB,QAC3CD,EAAII,aAAaxC,KAAgB0C,GAClCN,EAAIK,aAAazC,EAAY0C,IAGjC,YAAAG,SAAA,SAASC,GACP1B,KAAKiB,OAAOQ,SAAWC,EACvB1B,KAAKmB,WAGP,YAAAQ,MAAA,SAAM5C,GAIJ,MAHAiB,KAAKiB,OAAOQ,SAAWV,EACvBf,KAAKiB,OAAOU,MAAQ5C,EACpBiB,KAAKmB,UACCnB,KAAKiB,OAAOU,OAEtB,EAjCA,GCEaC,EAAa,SACbC,EAAc,SAE3B,aAEE,KAAAC,SAAW,IAGX,KAAAzC,SAAW,IAGX,KAAAP,IAjBsB,QAyBtB,KAAAiD,QAAsEH,EAGtE,KAAAxC,KAAOyC,GC5BT,2BAmEA,OA9DS,EAAAG,YAAP,SAAmBjD,GAOjB,MANoC,CAClCkD,MAAO,GACPC,IAAK,GACLT,SAAUV,EACVY,MAAO5C,IAQJ,EAAAoD,KAAP,SAAYC,GACV,IAAIC,EAOAC,EANJ,IACED,EAAWd,KAAKgB,MAAMH,GAExB,MAAOI,GACL,OAAOC,EAAaT,YAAY,oDAGlC,IACEM,EAAgBG,EAAaC,UAAUL,GAEzC,MAAOG,GACL,OAAOC,EAAaT,YAAY,gDAGlC,OAAOM,GAMM,EAAAI,UAAf,SAAyBC,GACvB,IAAIA,EAAK,OAAOF,EAAaT,YAAY,4BAEzC,IAAIW,EAAIT,IAAK,OAAOO,EAAaT,YAAY,mEAE7C,IAAIW,EAAIT,IAAIU,WAAW,UAAW,OAAOH,EAAaT,YAAY,gDAAkDW,EAAIT,KAExH,IAAIS,EAAIT,IAAIW,SAAS,MAAO,OAAOJ,EAAaT,YAAY,wDAA0DW,EAAIT,KAE1H,IAAMY,EAASvD,MAAMC,QAAQmD,EAAIV,OACzBU,EAAIV,MACJU,EAAIV,MACF,CAACU,EAAIV,OACL,GAYV,OARAa,EAAOC,KAAKJ,EAAIT,IAAIc,UAAU,EAAGL,EAAIT,IAAIvC,OAAO,IAEZ,CAClCsC,MAAOa,EACPZ,IAAKS,EAAIT,IACTT,SHjEyB,WGkEzBwB,KAAMN,EAAIM,OAIhB,EAnEA,GCGA,aAIE,WAAmBC,GAAA,KAAAA,OAFZ,KAAAC,KAAO,IAAI5D,MAwCpB,OAjCE,YAAA6D,aAAA,SAAaC,G,QAELC,EAAyB,QAAlB,EAAAD,aAAI,EAAJA,EAAMjC,oBAAY,oBAAlBiC,EAAqBzE,GAClC,GAAI0E,EAAJ,CACA,IAAMC,EAAyB,QAAlB,EAAAF,aAAI,EAAJA,EAAMjC,oBAAY,oBAAlBiC,EAAqBxE,GAElC,GADAC,EAAI,OAAQyE,GACTA,EAAM,OAAOzE,EAAI,QAEpBA,EAAI,OAAQwE,GACZ,IAAMrC,EAASwB,EAAaN,KAAKmB,GAC9BrC,EAAOQ,WAAaV,GAIvBjC,EAAI,iBACJkB,KAAKwD,IAAIH,EAAMpC,IAJb/B,QAAQyC,MAAMV,EAAOU,MAAO0B,EAAMC,KAUtC,YAAAE,IAAA,SAAIH,EAAmBpC,GACrBnC,EAAI,MAAOuE,EAAMpC,GACjB,IAAMD,EAAM,IAAIyC,EAAUJ,EAAMpC,GAChCjB,KAAKmD,KAAKJ,KAAK/B,GC/BZ,SAA+BkC,EAAkBlC,GACtD,IAAMC,EAASD,EAAIC,OACnBnC,EAAI,qBACJ,IAAMoC,EAASgC,EAAKQ,MAAMzB,MAAMhB,EAAOgB,OACvCjB,EAAIS,SLX2B,cKa/BP,EAAOyC,MAAK,WACV,IAAIrD,EAAMW,EAAOiB,IACjBpD,EAAI,qCAAuCwB,GAC3CU,EAAIS,SLfwB,aKgBxBnB,EAAIuC,SAAS,OACf7B,EAAIW,MAAM,uDAGZ,IAAMpB,GADND,EAAMA,EAAID,OAAO,EAAGC,EAAIX,OAAS,IACfa,MAAM,KACpBD,EAAMZ,OAAS,GAAiB,UAAZY,EAAM,IAC5BA,EAAME,QAKR,IAFA,IAAImD,EAAUjD,OACVC,EAAQ,SACHC,EAAI,EAAGA,EAAIN,EAAMZ,OAAQkB,IAAK,CACrC,IAAMC,EAAOP,EAAMM,GAGnBD,GAAS,IAAME,GAFf8C,EAAUA,EAAQ9C,KAKJE,EAAIW,MAAM,kCAAkCf,EAAK,6BAE1C,mBAAd,GAA0BI,EAAIW,MAAM,OAAOf,EAAK,4BAGzDgD,EAAQ,EAAD,KAAM3C,GAAM,CAAED,IAAKA,KAC1BA,EAAIS,SLvC0B,kBIqC9BoC,CAAsB7D,KAAKkD,KAAMlC,IAGnC,YAAA8C,WAAA,WACEhF,EAAI,eAAekB,KAAKmD,KAAKxD,QAC7BK,KAAKmD,KAAKY,SAAQ,SAACC,GAAM,OAAAA,EAAE7C,cAG/B,EA1CA,G,+MCyCAjC,QAAQJ,IAAI,UC1CZ,IAAMmC,EAAgC,CACpCgD,YAAY,EACZC,WAAW,EACXC,SAAS,GAMX,aAEE,WAAmBC,GAAA,KAAAA,aACjBpE,KAAKqE,kBA6BT,OA1BS,YAAAA,gBAAP,sBACEvF,EAAI,mBACJ,IAAMqE,EAAOmB,SAASC,iBAAiB,aACvCzF,EAAI,QAASqE,GACbA,EAAKY,SAAQ,SAACC,GAAmB,SAAKI,WAAWhB,aAAaY,OAGzD,YAAAQ,iBAAP,sBACE1F,EAAI,QAEa,IAAI2F,kBAAiB,SAACC,GACrC5F,EAAI,mBAEJ4F,EAAUX,SAAQ,SAACY,GAEJ,aAAVA,EAAEC,OACL9F,EAAI,gBAEJ6F,EAAEE,WAAWd,SAAQ,SAACV,GAAsB,SAAKe,WAAWhB,aAAaC,aAKpEyB,QAAQR,SAASS,gBAAiB9D,IAG/C,EAhCA,G,+MCXA,aAIE,WAAY+D,EAA6BC,GAKlC,KAAAC,WAAqB,IAAIrF,GAAO,EAAO,6BACvC,KAAAR,SAAW,EALhBW,KAAKmF,WAAaH,EAClBhF,KAAKiF,SAAWA,EA4CpB,OAnCS,YAAAE,WAAP,WAA8B,OAAO,IAAItF,GAAO,EAAM,yBAE/C,YAAAuF,MAAP,WACE,OAAIpF,KAAKkF,WAAW/F,QAGpBa,KAAKkF,WAAalF,KAAKmF,cAHWnF,KAAKkF,YAQlC,YAAAG,UAAP,WAEE,IAAM3E,EAASV,KACTsF,EAAiB,SAASC,EAAkCC,GAEhE,IAAMC,EAAS/E,EAAO0E,QAGnBK,EAAOtG,MACRoG,EAAQ,OAAME,GAAM,CAAEpG,SAAUqB,EAAOrB,YAItCqB,EAAOrB,YAAcqB,EAAOuE,SAAS5F,SACtCkG,EAAQ,OAAKE,GAAM,CAAE1G,QAAS,6BAA+B0G,EAAO1G,QAASM,SAAUqB,EAAOrB,YAKhGqG,WAAWJ,EAAgB5E,EAAOuE,SAASnD,SAAUyD,EAASC,IAGhE,OAAO,IAAIG,QAAQL,IAEvB,EAlDA,G,+MCCA,aAME,WAAYM,GAHL,KAAAX,SAAW,IAAIY,EAmFd,KAAAC,gBAAkB,IAAIC,EA/EE,iBAAnBH,IACTA,EAAiB,CACfxG,KAAMwG,IAINA,IACF5F,KAAKiF,SAAW,OAAKjF,KAAKiF,UAAaW,IAEzCI,EAAOC,QAyEX,OAlEE,YAAAvC,IAAA,SAAIkC,GACF,OAAO,IAAII,EAAOJ,IAGb,YAAA3D,MAAP,SAAaiE,GAAb,WAMQC,GAHmB5G,MAAMC,QAAQ0G,GAAeA,EAAa,CAACA,IAG7BE,KAAI,SAAAC,GAEzC,GAAIV,QAAQJ,QAAQc,KAAkBA,EACpC,OCtC4BC,EDsCDD,ECrC1B,IAAIV,SAAgB,SAACJ,EAASC,GACnCc,EACG3C,MAAK,SAAA4C,GAEJhB,EAAQ,IAAI1F,GADS,IAAN0G,EACY,oBAE5BC,OAAM,SAAAC,GAAU,OAAAjB,EAAOiB,SDiCtB,ICxC4BH,EDwCtBvG,EAAY,EAAK+F,gBAAgBhG,KAAKuG,GAE5C,OADe,IAAIK,EAAmB3G,EAAW,EAAKkF,UACxCI,eAMZsB,EAAS3G,KAGT4G,EAAgBZ,EAAOC,MA4B7B,OA1BkB,IAAIN,SAAuB,SAACJ,EAASC,GAErDG,QAAQkB,IAAIV,GAAgBxC,MAAK,SAAAmD,GAG/B,IAAMC,EAAU,IAAIC,EAAcF,GAOlC,IN/DgB,UM2DZH,EAAO1B,SAASnG,MAAsBiI,EAAQ5H,ON1DjC,WM0D0CwH,EAAO1B,SAASnG,MACzE6H,EAAOM,cAAcL,EAAeD,EAAO1B,SAAU6B,GAGnDC,EAAQ5H,MACVoG,EAAQ,IAAIyB,EAAcF,SAK5B,OAAQH,EAAO1B,SAASlD,SACtB,KAAKH,EAAY4D,EAAOuB,GAAU,MAClC,INnEiB,UMmECxB,EAAQwB,GAAU,MACpC,INrEgB,SMqEC,eAQlB,YAAAE,cAAP,SAAqBC,EAAYjC,EAAoBkC,GACnDjI,QAAQJ,IAAI,WAAWoI,EAAE,KACtBjC,EAAS7F,OAASyC,EAAc,IAAIoD,EAAS7F,KAAI,KAAO,IACzD,wEAAyE+H,IAK9D,EAAAlB,MAAQ,EACzB,EAzFA,GEAA,aAME,aAEEjG,KAAKoE,WAAa,IAAIgD,EAAiBpH,MACvCA,KAAKqH,OAAS,IAAIC,EAAUtH,KAAKoE,YAUrC,OAHE,YAAAV,IAAA,SAAIkC,GACF,OAAO,IAAII,EAAOJ,IAEtB,EAnBA,GCOM2B,EAAM5G,OACP4G,EAAIrG,SAAQqG,EAAIrG,OAAS,IAAIsG,GACnBD,EAAIrG,OAEZmG,OAAO7C,qBCdViD,EAA2B,GAG/B,SAASC,EAAoBC,GAE5B,GAAGF,EAAyBE,GAC3B,OAAOF,EAAyBE,GAAUC,QAG3C,IAAIC,EAASJ,EAAyBE,GAAY,CAGjDC,QAAS,IAOV,OAHAE,EAAoBH,GAAUE,EAAQA,EAAOD,QAASF,GAG/CG,EAAOD,QCnBfF,EAAoBK,EAAI,CAACH,EAASI,KACjC,IAAI,IAAI1H,KAAO0H,EACXN,EAAoBO,EAAED,EAAY1H,KAASoH,EAAoBO,EAAEL,EAAStH,IAC5E4H,OAAOC,eAAeP,EAAStH,EAAK,CAAE8H,YAAY,EAAMC,IAAKL,EAAW1H,MCJ3EoH,EAAoBO,EAAI,CAACK,EAAKC,IAASL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,GCEjFb,EAAoB,M","file":"turn-on.js","sourcesContent":["\r\nexport const attrConfig = 'turn-on';\r\nexport const attrSkip = 'turn-on-skip';\r\n","\r\nconst debug = true;\r\n\r\nexport function log(message: string, obj1?: unknown, obj2?: unknown): void {\r\n  if(!debug) return;\r\n  if(obj2) console.log('turn-on: ' + message, obj1, obj2);\r\n  else if(obj1)  console.log('turn-on: ' + message, obj1);\r\n  else console.log('turn-on: ' + message);\r\n}","\r\nconst nameNotDefined = 'not set';\r\nexport class Status {\r\n  constructor(\r\n\r\n    /** Status if the check has been successful */\r\n    public ready: boolean,\r\n\r\n    /** Status message if provided */\r\n    public message: string, \r\n    \r\n    /** name of this status, to better point to which rule failed */\r\n    public name: string = nameNotDefined) {\r\n  }\r\n\r\n  /** Amount of attempts tried till this  */\r\n  attempts? = 0;\r\n}\r\n","import { Status } from '.';\r\n\r\n\r\nexport class StatusSummary extends Status {\r\n\r\n  constructor(details: Status[]) {\r\n    // no details provided, then assume ok\r\n    if (!details) details = [];\r\n\r\n    const ready = detectIfAllOk(details);\r\n\r\n    const message = details.length === 0\r\n      ? 'no conditions provided'\r\n      : ready\r\n        ? 'all ok'\r\n        : 'some conditions did not complete';\r\n    super(ready, message, 'Summary');\r\n    this.details = details;\r\n  }\r\n\r\n  /** Details of each of the status received */\r\n  details: Status[]\r\n}\r\n\r\nfunction detectIfAllOk(details: Status[]) {\r\n  // some kind of error appeared, shouldn't be ok\r\n  if (!Array.isArray(details)) return false;\r\n\r\n  // count if all details have a ready-state\r\n  return (details.filter(stat => stat.ready).length == details.length)\r\n}","import { Condition, ConditionRaw } from '.';\r\nimport { Status } from '../status/status';\r\n\r\n/**\r\n * Internal class to generate is-it-ready checkers\r\n */\r\nexport class ConditionMaker {\r\n\r\n  /**\r\n   * Make a new condition checker\r\n   */\r\n  public make(condition: ConditionRaw): Condition {\r\n    if (typeof(condition) === 'function')\r\n      return this.fnChecker(condition);\r\n    \r\n    if (typeof(condition) === 'string')\r\n      return this.keyChecker(condition);\r\n\r\n  }\r\n\r\n\r\n  fnChecker(fn: () => boolean): Condition {\r\n    let name = fn.toString();\r\n    if (name && name.length > 25) name = name.substr(0, 25);\r\n    return () => { \r\n      return {\r\n        name,\r\n        ready: fn(),\r\n        message: ''\r\n      } as Status;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a checker which verifies if a key or key-sequence on window exists\r\n   * @param key \r\n   */\r\n  keyChecker(key: string): Condition {\r\n    // empty-ish strings - always say it's done\r\n    if (!key) return () => new Status(true, 'empty key', key);\r\n\r\n    const parts = key.split('.');\r\n    if (parts.length > 0 && parts[0] == 'window')\r\n      parts.shift();\r\n\r\n    if (parts.length == 0) return () => new Status(true, 'no keys except maybe windows found', key);\r\n\r\n    return () => {\r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      let parent = window as any;\r\n      let match = 'window';\r\n      for (let i = 0; i < parts.length; i++) {\r\n        const part = parts[i];\r\n        parent = parent[part];\r\n        // if node not found, stop checking\r\n        if (!parent) break;\r\n\r\n        // found, so let's add to list of successful matches\r\n        match += '.' + part;\r\n\r\n        // if we got to the end, it's good\r\n        if (i == parts.length - 1) return new Status(true, 'all keys matched', key); \r\n      }\r\n      return new Status(false, `Not all keys matched yet. So far '${match}' worked.`, key);\r\n    }\r\n  }\r\n}","export const Progress1Loaded = '1-loaded';\r\nexport const Progress2Watching = '2-watching';\r\nexport const Progress3Running = '3-running';\r\nexport const Progress4Completed = '4-completed';\r\nexport const Progress9Cancelled = '9-cancelled';\r\nexport const ProgressError = '9-error';\r\n\r\nexport type TurnOnProgres = typeof Progress1Loaded | typeof Progress2Watching  | typeof Progress3Running | typeof Progress4Completed | typeof Progress9Cancelled | typeof ProgressError ;\r\n\r\nexport interface TurnOnConfiguration {\r\n  await: string[];\r\n\r\n  run: string;\r\n\r\n  progress: TurnOnProgres;\r\n\r\n  error?: string;\r\n\r\n  data?: unknown;\r\n}\r\n","import { TurnOnConfiguration, TurnOnProgres } from '../configuration';\r\nimport { attrConfig, attrSkip } from '..';\r\nimport { log } from '../debug';\r\nimport { TurnOn } from '../turnOn/turn-on';\r\nimport { ProgressError } from '../configuration/configuration';\r\n\r\n\r\nexport class ConfigTag {\r\n\r\n  constructor(\r\n    public tag: HTMLElement,\r\n    public config: TurnOnConfiguration,\r\n    public turnOn?: TurnOn\r\n  ) \r\n  { \r\n    this.syncDom();\r\n  }\r\n\r\n  syncDom(): void {\r\n    log('syncDom', this);\r\n    const tag = this.tag;\r\n    // set skip if missing and update json in html if not current\r\n    // Do these checks to avoid to many DOM changes\r\n    if(!tag.getAttribute(attrSkip)) tag.setAttribute(attrSkip, \"skip\");\r\n    const currentSerialized = JSON.stringify(this.config);\r\n    if(tag.getAttribute(attrConfig) !== currentSerialized)\r\n      tag.setAttribute(attrConfig, currentSerialized);\r\n  }\r\n\r\n  progress(prog: TurnOnProgres): void {\r\n    this.config.progress = prog;\r\n    this.syncDom();\r\n  }\r\n\r\n  error(message: string): void {\r\n    this.config.progress = ProgressError;\r\n    this.config.error = message;\r\n    this.syncDom();\r\n    throw this.config.error;\r\n  }\r\n}","\r\n// this must be a simple const, otherwise the anotation below with typeof won't work\r\n// https://stackoverflow.com/questions/56263200/how-to-define-string-literal-union-type-from-constants-in-typescript\r\nexport const LogError = 'error';\r\nexport const LogDebug = 'debug';\r\nexport const LogSilent = 'silent';\r\n\r\nexport const FailSilent = 'silent';\r\nexport const FailResolve = 'resolve';\r\nexport const FailReject = 'reject';\r\nexport const DefaultName = 'turnOn';\r\n\r\nexport class Settings {\r\n  /** the polling interval - defaults to 100 */\r\n  interval = 100;\r\n\r\n  /** polling attempts, defaults to 100 */\r\n  attempts = 100;\r\n \r\n  /** What to log into the console */\r\n  log: typeof LogError | typeof LogDebug | typeof LogSilent = LogError;\r\n\r\n  /**\r\n   * Failure mode, if by timeout it's not successful\r\n   * - reject (default)= use promise reject (which will throw an error if not handled)\r\n   * - resolve = use promise resolve and give a status back which says it's not complete\r\n   * - silent = don't complete the promise\r\n   */\r\n  failure: typeof FailReject | typeof FailResolve | typeof FailSilent = FailReject;\r\n\r\n  /** The name of this turnOn - to better track issues */\r\n  name = DefaultName;\r\n}","import { Progress1Loaded, ProgressError, TurnOnConfiguration } from '.';\r\nimport { TurnOnConfigurationRaw } from '..';\r\n\r\nexport class ConfigHelper {\r\n\r\n  /**\r\n   * Create a configuration object which just contains an error\r\n   */\r\n  static createError(message: string): TurnOnConfiguration {\r\n    const result: TurnOnConfiguration = {\r\n      await: [],\r\n      run: '',\r\n      progress: ProgressError,\r\n      error: message\r\n    };\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Load a configuration from a string usually from an Html attribute\r\n   */\r\n  static load(value: string): TurnOnConfiguration {\r\n    let pretyped: TurnOnConfigurationRaw;\r\n    try {\r\n      pretyped = JSON.parse(value);\r\n    }\r\n    catch (ex) {\r\n      return ConfigHelper.createError(`detected configuration but cannot parse to json.`);\r\n    }\r\n    let configuration: TurnOnConfiguration;\r\n    try {\r\n      configuration = ConfigHelper.stabilize(pretyped);\r\n    }\r\n    catch (ex) { \r\n      return ConfigHelper.createError(`Error loading configuration, reason unknown.`)\r\n    }\r\n  \r\n    return configuration;\r\n  }\r\n\r\n  /**\r\n   * Import a raw configuration and make sure it's fully compliant\r\n   */\r\n  private static stabilize(raw: TurnOnConfigurationRaw): TurnOnConfiguration {\r\n    if(!raw) return ConfigHelper.createError('No data found to process');\r\n  \r\n    if(!raw.run) return ConfigHelper.createError(`Configuration didn't contain run - that's the minimum required.`);\r\n\r\n    if(!raw.run.startsWith('window')) return ConfigHelper.createError(`run command must start with 'window.' but is:` + raw.run);\r\n  \r\n    if(!raw.run.endsWith('()')) return ConfigHelper.createError(`run must be a function name and end with () but it's:` + raw.run);\r\n  \r\n    const awaits = Array.isArray(raw.await) \r\n          ? raw.await\r\n          : raw.await \r\n            ? [raw.await]\r\n            : [];\r\n  \r\n    // also always await the run command, but without the () as it shouldn't be called to detect if it's ready\r\n    \r\n    awaits.push(raw.run.substring(0, raw.run.length-2));\r\n  \r\n    const stable: TurnOnConfiguration = {\r\n      await: awaits,\r\n      run: raw.run,\r\n      progress: Progress1Loaded,\r\n      data: raw.data,\r\n    }\r\n    return stable;\r\n  }\r\n}","import { TurnOnConfiguration } from '../configuration';\r\nimport { attrConfig, attrSkip, log } from '..';\r\nimport { TurnOnRoot } from '../turnOn';\r\nimport { ConfigTag, convertConfigToTurnOn } from '.';\r\nimport { ConfigHelper, ProgressError } from '../configuration';\r\n\r\nexport class ConfigTagManager {\r\n  \r\n  public tags = new Array<ConfigTag>();\r\n\r\n  constructor(public root: TurnOnRoot) {\r\n    \r\n  }\r\n\r\n\r\n  tryToLoadTag(node: HTMLElement): void {\r\n    // Get config and skip if not relevant, or skip if already marked as in the queue\r\n    const attr = node?.getAttribute?.(attrConfig);\r\n    if(!attr) return;\r\n    const skip = node?.getAttribute?.(attrSkip);\r\n    log('skip', skip);\r\n    if(skip) return log('skip');\r\n\r\n    log('attr', attr);\r\n    const config = ConfigHelper.load(attr);\r\n    if(config.progress === ProgressError) {\r\n      console.error(config.error, node, attr);\r\n      return;\r\n    }\r\n    log('stable config')\r\n    this.add(node, config);\r\n  }\r\n  \r\n  /**\r\n   * \r\n   */\r\n  add(node: HTMLElement, config: TurnOnConfiguration): void {\r\n    log('add', node, config);\r\n    const tag = new ConfigTag(node, config);\r\n    this.tags.push(tag);\r\n    convertConfigToTurnOn(this.root, tag);\r\n  }\r\n\r\n  updateTags(): void {\r\n    log(`updateTags: ${this.tags.length}`);\r\n    this.tags.forEach((t) => t.syncDom())\r\n  }\r\n\r\n}","import { ConfigTag } from '.';\r\nimport { log, Status } from '..';\r\nimport { Progress2Watching, Progress3Running, Progress4Completed } from '../configuration';\r\nimport { TurnOnRoot } from '../turnOn';\r\n\r\n/**\r\n * \r\n */\r\nexport function convertConfigToTurnOn(root: TurnOnRoot, tag: ConfigTag): Promise<Status> {\r\n  const config = tag.config;\r\n  log('convert to turnon');\r\n  const turnOn = root.new().await(config.await);\r\n  tag.progress(Progress2Watching);\r\n\r\n  turnOn.then(() => {\r\n    let key = config.run;\r\n    log('turn on success - will try to run ' + key);\r\n    tag.progress(Progress3Running);\r\n    if(!key.endsWith('()')) \r\n      tag.error(`run should end with () but doesn't - can't continue`);\r\n\r\n    key = key.substr(0, key.length - 2);\r\n    const parts = key.split('.');\r\n    if (parts.length > 0 && parts[0] == 'window')\r\n      parts.shift();\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    let current = window as any;\r\n    let match = 'window';\r\n    for (let i = 0; i < parts.length; i++) {\r\n      const part = parts[i];\r\n      current = current[part];\r\n      // found, so let's add to list of successful matches\r\n      match += '.' + part;\r\n\r\n      // if node not found, stop checking\r\n      if (!current) tag.error(`Tried to find object parts for ${match} but didn't get anything.`);\r\n    }\r\n    if(typeof(current) !== 'function') tag.error(`Got ${match} but it's not a function`);\r\n\r\n    // now run it!\r\n    current({ ...config, tag: tag });\r\n    tag.progress(Progress4Completed);\r\n  });\r\n  return turnOn;\r\n}\r\n\r\nconsole.log('hello!');","import { ConfigTagManager, log } from '..';\r\n\r\n/**\r\n * Options for the observer (which mutations to observe)\r\n */\r\nconst config : MutationObserverInit = { \r\n  attributes: false, \r\n  childList: true, \r\n  subtree: true \r\n};\r\n\r\n/**\r\n * In charge of loading all turn-on tags from the DOM, both at first load as well as on DOM changes\r\n */\r\nexport class TagLoader {\r\n\r\n  constructor(public tagManager: ConfigTagManager) {\r\n    this.scanExistingDom();\r\n  }\r\n\r\n  public scanExistingDom(): void {\r\n    log('scanExistingDom');\r\n    const tags = document.querySelectorAll(`[turn-on]`);\r\n    log('tags:', tags);\r\n    tags.forEach((t: HTMLElement) => this.tagManager.tryToLoadTag(t));\r\n  }\r\n\r\n  public activateObserver(): void {\r\n    log('load');\r\n  \r\n    const observer = new MutationObserver((mutations) => {\r\n      log('turnOn mutation');\r\n      // Loop through each changed item, check if it's something we want to initialize\r\n      mutations.forEach((m) => {\r\n        // Nodes added - let's check if it is a turn-on\r\n        if(m.type != 'childList') return;\r\n        log('hit children');\r\n\r\n        m.addedNodes.forEach((node: HTMLElement) => this.tagManager.tryToLoadTag(node));\r\n      });\r\n    });\r\n  \r\n    // observe document for tags which include this. ATM don't observe header\r\n    observer.observe(document.documentElement, config);\r\n  }\r\n\r\n}\r\n","import { Status } from '..';\r\nimport { Settings } from '../turnOn';\r\n\r\nexport class ConditionAsPromise {\r\n\r\n  public settings: Settings;\r\n\r\n  constructor(checkFunction: () => Status, settings: Settings) {\r\n    this.innerCheck = checkFunction;\r\n    this.settings = settings;\r\n  }\r\n\r\n  public lastStatus: Status = new Status(false, 'condition not checked yet');\r\n  public attempts = 0;\r\n\r\n  /**\r\n   * Dummy innerCheck function - should be replaced in the constructor\r\n   */\r\n  public innerCheck(): Status { return new Status(true, 'no condition defined') } ;\r\n\r\n  public check(): Status {\r\n    if (this.lastStatus.ready) return this.lastStatus;\r\n\r\n    // check and store\r\n    this.lastStatus = this.innerCheck();\r\n\r\n    return this.lastStatus;\r\n  }\r\n\r\n  public asPromise(): Promise<Status> {\r\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n    const parent = this;\r\n    const checkCondition = function(resolve: (value: Status) => void, reject: (reason: unknown | null) => void) {\r\n      // If the condition is met, we're done! \r\n      const result = parent.check();\r\n\r\n      // if all is ok (true) then complete the promise\r\n      if(result.ready) {\r\n        resolve( { ...result, attempts: parent.attempts });\r\n        return;\r\n      }\r\n\r\n      if(parent.attempts++ >= parent.settings.attempts) {\r\n        resolve({ ...result, message: 'tried up to max attempts: ' + result.message, attempts: parent.attempts });\r\n        return;\r\n      }\r\n\r\n      // If the condition isn't met but the timeout hasn't elapsed, go again\r\n      setTimeout(checkCondition, parent.settings.interval, resolve, reject);\r\n    };\r\n\r\n    return new Promise(checkCondition)\r\n  }\r\n}\r\n","import { Settings, LogDebug, LogSilent } from '.';\r\nimport { DefaultName, FailReject, FailResolve, FailSilent } from './settings';\r\nimport { promiseBoolToStatus } from '../watch-promise/promise-boolean-as-promise';\r\nimport { ConditionAsPromise, ConditionMaker, ConditionRaw, Status, StatusSummary } from '..';\r\nexport class TurnOn {\r\n\r\n  /** The settings applied to this turnOn */\r\n  public settings = new Settings();\r\n\r\n  /** Constructor with optional settings */\r\n  constructor(nameOrSettings?: Partial<Settings> | string) {\r\n    if (typeof nameOrSettings === 'string') {\r\n      nameOrSettings = {\r\n        name: nameOrSettings\r\n      };\r\n    }\r\n\r\n    if (nameOrSettings)\r\n      this.settings = { ...this.settings, ...nameOrSettings };\r\n\r\n    TurnOn.count++;\r\n  }\r\n\r\n  /**\r\n   * Create a new turnOn object.\r\n   * Mainly usefuly in global scenarios, to give it a separate name\r\n   */\r\n  new(nameOrSettings?: Partial<Settings>): TurnOn {\r\n    return new TurnOn(nameOrSettings);\r\n  }\r\n\r\n  public await(conditions: ConditionRaw | ConditionRaw[]): Promise<Status> {\r\n\r\n    // re-wrap to ensure we always work with an array\r\n    const conditionsArray = (Array.isArray(conditions)) ? conditions : [conditions];\r\n\r\n    // convert conditions to promises\r\n    const loadedCheckers = conditionsArray.map(c => {\r\n      // do this for non-promise conditions\r\n      if (Promise.resolve(c as unknown) === c) {\r\n        return promiseBoolToStatus(c);\r\n      } else {\r\n        const condition = this._conditionMaker.make(c);\r\n        const loaded = new ConditionAsPromise(condition, this.settings);\r\n        return loaded.asPromise();  \r\n      }\r\n    });\r\n\r\n    // keep the current turnOn-object for reference in methods\r\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n    const thisKs = this;\r\n\r\n    // keep count as it was on start, to ensure it doesn't change any more till we log the error\r\n    const instanceCount = TurnOn.count;\r\n\r\n    const flattened = new Promise<StatusSummary>((resolve, reject) => { \r\n      // return a single promise for all inner promises which either fail or resolve\r\n      Promise.all(loadedCheckers).then(list => {\r\n\r\n        // get summary of all details infos\r\n        const summary = new StatusSummary(list);\r\n\r\n        // by default, log details about what failed\r\n        if (thisKs.settings.log === LogDebug || (!summary.ready && thisKs.settings.log !== LogSilent))\r\n          thisKs.logStatusList(instanceCount, thisKs.settings, list);\r\n\r\n        // if all is ok, resolve now\r\n        if (summary.ready) {\r\n          resolve(new StatusSummary(list));\r\n          return;\r\n        }\r\n\r\n        // depending on the need, either reject/error (default) or resolve with false\r\n        switch (thisKs.settings.failure){\r\n          case FailReject: reject(summary); break;\r\n          case FailResolve: resolve(summary); break;\r\n          case FailSilent: return;\r\n        }\r\n      })\r\n    });\r\n      \r\n    return flattened;\r\n  }\r\n\r\n  public logStatusList(id: number, settings: Settings, statusList: Status[]): void {\r\n    console.log(`turnOn #${id} `\r\n    + (settings.name !== DefaultName ? `\"${settings.name}\" ` : '')\r\n    + `couldn't complete because some conditions were not met. See details: `, statusList);\r\n  }\r\n\r\n  private _conditionMaker = new ConditionMaker();\r\n\r\n  private static count = 0;\r\n}","import { Status } from '..';\r\n\r\nexport function promiseBoolToStatus(boolPromise: Promise<boolean>): Promise<Status> {\r\n  return new Promise<Status>((resolve, reject) => {\r\n    boolPromise\r\n      .then(r => {\r\n        const result = r !== false;\r\n        resolve(new Status(result, 'from promise'));\r\n    })\r\n      .catch(reason => reject(reason));\r\n  });\r\n}\r\n","import { Settings, TurnOn } from '.';\r\nimport { TagLoader } from '..';\r\nimport { ConfigTagManager } from '../tags/config-tag-manager';\r\n\r\nexport class TurnOnRoot {\r\n  \r\n  tagManager: ConfigTagManager;\r\n\r\n  loader: TagLoader;\r\n\r\n  constructor()\r\n  {\r\n    this.tagManager = new ConfigTagManager(this);\r\n    this.loader = new TagLoader(this.tagManager);\r\n  }\r\n\r\n  /**\r\n   * Create a new turnOn object.\r\n   * Mainly usefuly in global scenarios, to give it a separate name\r\n   */\r\n  new(nameOrSettings?: Partial<Settings>): TurnOn {\r\n    return new TurnOn(nameOrSettings);\r\n  }\r\n}","\r\nexport * from './constants';\r\nexport * from './debug';\r\n\r\nexport * from './status';\r\nexport * from './conditions';\r\nexport * from './tags';\r\nexport * from './watch-promise';\r\n\r\nimport { TurnOnRoot } from './turnOn';\r\n\r\nconst win = window as any;\r\nif (!win.turnOn) win.turnOn = new TurnOnRoot();\r\nconst turnOn = win.turnOn as TurnOnRoot;\r\n\r\nturnOn.loader.activateObserver();\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)","// startup\n// Load entry module\n__webpack_require__(724);\n// This entry module used 'exports' so it can't be inlined\n"],"sourceRoot":""}